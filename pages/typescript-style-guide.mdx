import { Callout } from 'nextra/components';

# TypeScript Style Guide

Оригинальное руководство по стилю от Google: [https://google.github.io/styleguide/tsguide.html](https://google.github.io/styleguide/tsguide.html).

## 2 Основы исходного файла

### 2.1 Кодировка файлов: UTF-8

Исходные файлы имеют кодировку **UTF-8**.

#### 2.1.3 Символы, отличные от ASCII

Для символов, отличных от ASCII, используйте фактический символ Юникода (например `∞`). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например `\u221e`) вместе с пояснительным комментарием.

```typescript
// ✅ ХОРОШО

// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
```

```typescript
// ❌ ПЛОХО

// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
```

## 4 Особенности языка

В этом разделе описывается, какие функции можно или нельзя использовать, а также любые дополнительные ограничения на их использование.

Возможности языка TypeScript, которые не рассматриваются в данном руководстве, возможно использовать без каких-либо рекомендаций по их применению.

### 4.1 Объявления локальных переменных

#### 4.1.1 Используйте const и let

Всегда используйте `const` или `let` для объявления переменных. По умолчанию используйте `const`, если не требуется переназначение переменной. Никогда не используйте `var`.

```typescript
// ✅ ХОРОШО

const foo = otherValue; // Используйте, если "foo" никогда не меняется.
let bar = someValue; // Используйте, если для "bar" когда-либо позднее будет присвоено значение
```

`const` и `let` имеют блочную область видимости, как и переменные в большинстве других языков. `var` в JavaScript ограничен областью действия функции, что может вызвать трудные для понимания ошибки. Не используйте его.

```typescript
// ❌ ПЛОХО

var foo = someValue; // Не используйте - область видимости var сложна и подвержена ошибкам.
```

Переменные _не должны_ использоваться до их объявления.

### 4.2 Литералы массива

#### 4.2.1 Не используйте `Array` конструктор

В коде на Typescript `не должен` использоваться `Array()` конструктор, с или без `new`. Его применение неоднозначно и сбивает с толку:

```typescript
// ❌ ПЛОХО

const a = new Array(2); // [undefined, undefined]
const b = new Array(2, 3); // [2, 3];
```

Вместо этого всегда используйте скобки для инициализации массивов или `from` для инициализации `Array` с определенным размером:

```typescript
// ✅ ХОРОШО

const a = [2];
const b = [2, 3];

// Эквивалент для Array(2):
const c = [];
c.length = 2;

// [0, 0, 0, 0, 0]
Array.from<number>({ length: 5 }).fill(0);
```

#### 4.2.3 Применение spread-оператора

### 4.3 Литералы объектов

#### 4.3.2 Итерация по объектам

Итерация по объектам с помощью `for (... in ...)` подвержена вероятным ошибкам, т.к. это включает в себя все перечисляемые свойства из цепочки прототипов.

Не используйте не фильтрованные `for (... in ...)` выражения:

```typescript
// ❌ ПЛОХО

for (const x in someObj) {
  // x может происходить от некоторого родительского прототипа!
}
```

Либо явно отфильтруйте значения с помощью оператора `if`, либо используйте `for (... of Object.keys(...))`.

{/* prettier-ignore */}
```typescript
// ✅ ХОРОШО

for (const x in someObj) {
  if (!someObj.hasOwnProperty(x)) continue;
  // сейчас x был точно определен в принадлежности someObj
}
for (const x of Object.keys(someObj)) { // примечание: for _of_!
  // сейчас x был точно определен в принадлежности someObj
}
for (const [key, value] of Object.entries(someObj)) { // примечание: for _of_!
  // сейчас key был точно определен в принадлежности someObj
}
```

### 4.4 Классы

#### 4.4.4 Конструкторы

При вызове конструктора всегда _должны_ использоваться скобки, даже если никакие аргументы не передаются:

{/* prettier-ignore */}
```typescript
// ❌ ПЛОХО

const x = new Foo;
```

```typescript
// ✅ ХОРОШО

const x = new Foo();
```

Отсутствие скобок может привести к тонким ошибкам. Эти две строки не эквивалентны:

```typescript
new Foo().Bar();
new Foo.Bar();
```

Нет необходимости предоставлять пустой конструктор или конструктор, который просто делегирует в родительский класс, поскольку ES2015 предоставляет конструктор класса по умолчанию, если он не указан. Однако _не рекомендуется_ убирать конструкторы с параметризованными свойствами, модификаторами области видимости или декораторами параметров, даже если тело конструктора пустое.

```typescript
// ❌ ПЛОХО

class UnnecessaryConstructor {
  constructor() {}
}
```

```typescript
// ❌ ПЛОХО

class UnnecessaryConstructorOverride extends Base {
  constructor(value: number) {
    super(value);
  }
}
```

```typescript
// ✅ ХОРОШО

class DefaultConstructor {}

class ParameterProperties {
  constructor(private myService) {}
}

class ParameterDecorators {
  constructor(@SideEffectDecorator myService) {}
}

class NoInstantiation {
  private constructor() {}
}
```

Конструктор должен быть отделен от окружающего кода сверху и снизу одной пустой строкой:

```typescript
// ✅ ХОРОШО

class Foo {
  myField = 10;

  constructor(private readonly ctorParam) {}

  doThing() {
    console.log(ctorParam.getThing() + myField);
  }
}
```

```typescript
// ❌ ПЛОХО

class Foo {
  myField = 10;
  constructor(private readonly ctorParam) {}
  doThing() {
    console.log(ctorParam.getThing() + myField);
  }
}
```

#### 4.4.5 Члены класса

**Не используйте приватные поля вида `#private`**

Не используйте приватные поля (также известные как приватные идентификаторы):

```typescript
// ❌ ПЛОХО

class Clazz {
  #ident = 1;
}
```

Вместо этого используйте поддерживаемые TypeScript аннотации видимости:

```typescript
// ✅ ХОРОШО

class Clazz {
  private ident = 1;
}
```

<Callout
  type="info"
  emoji="ℹ️"
>
Почему?

Приватные идентификаторы вызывают существенные проблемы с размером и производительностью при понижении версии стандарта ECMAScript, в которую будет скомпилирован код TypeScript и не поддерживаются до ES2015. Они могут быть понижены только до уровня ES2015, но не ниже. В то же время, они не дают существенных преимуществ, когда для контроля области видимости используется статическая проверка типов.

</Callout>

**Используйте модификатор `readonly`**

Пометьте модификатором `readonly` те свойства, которые никогда не переназначаются вне конструктора (они не обязательно должны быть глубоко неизменяемыми).

**Параметризованные свойства**

Вместо того чтобы просто передавать очевидный инициализатор в член класса, используйте [параметризованные свойства](https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties) TypeScript.

```typescript
// ❌ ПЛОХО

class Foo {
  private readonly barService: BarService;

  constructor(barService: BarService) {
    this.barService = barService;
  }
}
```

```typescript
// ✅ ХОРОШО

class Foo {
  constructor(private readonly barService: BarService) {}
}
```

Если параметризованное свойство нуждается в документировании, то [используйте JSDoc тег @param]().

**Инициализаторы полей**

Если элемент класса не является параметризованным свойством, инициализируйте его там, где он объявлен, что иногда позволяет совсем отбросить конструктор.

```typescript
// ❌ ПЛОХО

class Foo {
  private readonly userList: string[];

  constructor() {
    this.userList = [];
  }
}
```

```typescript
// ✅ ХОРОШО

class Foo {
  private readonly userList: string[] = [];
}
```

<Callout
  type="info"
  emoji="ℹ️"
>
  Совет: Свойства никогда не следует добавлять или удалять из экземпляра после
  завершения работы конструктора, поскольку это существенно ограничивает
  возможности виртуальных машин оптимизировать "форму" классов. Необязательные
  поля, которые могут быть заполнены позже, должны быть явно инициализированы
  как `undefined`, чтобы предотвратить последующие изменения формы.
</Callout>

**Свойства, используемые за пределами лексической области класса**

Для свойств, так или иначе задействованных вне лексической области видимости содержащего их класса, например, для свойств контроллера Angular используемых из шаблона, _не должна_ использоваться приватная (`private`) область видимости, т.к. к этим свойствам потребуется доступ за пределами лексической области видимости их класса.

Для этих свойств используйте либо `protected`, либо `public`, в зависимости от того, что подходит. Для свойств используемых в шаблонах Angular и AngularJS следует использовать `protected`, а в Polymer - `public`.

В TypeScript коде _не должны_ использоваться `obj['foo']` для обхода ограничения видимости свойства.

<Callout
  type="info"
  emoji="ℹ️"
>
Почему?

Когда свойство является приватным (`private`), вы объявляете автоматизированным системам и людям, что доступ к свойству ограничен методами объявленного класса, и они будут полагаться на это. Например, проверка на неиспользуемый код отметит приватное свойство, которое может посчитаться неиспользуемым, даже если какому-то коду из другого файла удастся обойти ограничение видимости.

Хотя это и кажется, что `obj['foo']` может обойти область видимости в компиляторе TypeScript, эта схема может быть нарушена путем изменения правил сборки, а также нарушается согласованность с оптимизациями.

</Callout>

**Геттеры и Сеттеры (Аксессоры)**

Для членов класса _возможно_ иcпользовать геттеры и сеттеры. Методы-геттеры _должны_ быть чистыми функциями (т.е. не иметь побочных эффектов и каждый раз возвращать одинаковый результат при одних и тех же параметрах). Они также полезны как средство ограничения видимости внутренних или подробных деталей реализации (показано ниже).

```typescript
// ✅ ХОРОШО

class Foo {
  constructor(private readonly someService: SomeService) {}

  get someMember(): string {
    return this.someService.someVariable;
  }

  set someMember(newValue: string) {
    this.someService.someVariable = newValue;
  }
}
```

```typescript
// ❌ ПЛОХО

class Foo {
  nextId = 0;
  get next() {
    return this.nextId++; // ПЛОХО: геттер меняет наблюдаемое состояние
  }
}
```

Если аксессор используется для сокрытия свойства класса, то для скрытого свойства _возможно_ указать префикс или суффикс с любым целым словом, например `internal` или `wrapped`. При использовании этих приватных свойств по возможности обращайтесь к их значению через аксессор. По крайней мере один аксессор к свойству _должен_ быть нетривиальным: не определяйте сквозные аксессоры только для того, чтобы скрыть свойство. Вместо этого сделайте свойство публичным (или подумайте о том, чтобы сделать его доступным только для чтения (`readonly`), чем просто определять геттер без сеттера).

```typescript
// ✅ ХОРОШО

class Foo {
  private wrappedBar = '';
  get bar() {
    return this.wrappedBar || 'bar';
  }

  set bar(wrapped: string) {
    this.wrappedBar = wrapped.trim();
  }
}
```

```typescript
// ❌ ПЛОХО

class Bar {
  private barInternal = '';
  // Ни один из этих аксессоров не имеет логики, поэтому просто сделайте bar публичным
  get bar() {
    return this.barInternal;
  }

  set bar(value: string) {
    this.barInternal = value;
  }
```

Геттеры и сеттеры _не должны_ определяться с помощью `Object.defineProperty`, поскольку это мешает переименованию свойств.

#### 4.4.6 Видимость

Ограничение видимости свойств, методов и целых типов помогает сохранить код слабо связанным.

- Максимально ограничивайте область видимости обозначений.
- Рассмотрите возможность преобразования приватных методов в неэкспортируемые функции в том же файле, но вне какого-либо класса, а также перемещение приватных свойств в отдельные, неэкспортируемые классы.
- В TypeScript все обозначения по умолчанию публичные. Никогда не используйте модификатор `public`, за исключением случаев объявления доступных для чтения и записи (т.е. не `readonly`) публичных параметризованных свойств (в конструкторе).

```typescript
// ❌ ПЛОХО

class Foo {
  public bar = new Bar(); // ПЛОХО: нет необходимости в модификаторе "public"

  constructor(public readonly baz: Baz) {} // ПЛОХО: модификатор "readonly" подразумевает, что это свойство имеет по умолчанию модификатор "public"
}
```

```typescript
// ✅ ХОРОШО

class Foo {
  bar = new Bar(); // ХОРОШО: нет необходимости в модификаторе "public"

  constructor(public baz: Baz) {} // допускается модификатор "public"
}
```

См. также [Область видимости экспортируемых элементов]() ниже.

### 4.8 Примитивные литералы

#### 4.8.3 Преобразование типов

В TypeScript коде _возможно_ использовать `String()` и `Boolean()` (примечание: без `new`!) функции, строковые шаблонные литералы или `!!` для преобразования типов.

```typescript
// ✅ ХОРОШО

const bool = Boolean(false);
const str = String(aNumber);
const bool2 = !!str;
const str2 = `result: ${bool2}`;
```

Значения перечислений `enum` (включая объединения перечислений и других типов) _не должны_ преобразовываться в логические значения с помощью `Boolean()` или `!!`, а должны вместо этого сравниваться явным образом с помощью операторов сравнения.

```typescript
// ❌ ПЛОХО

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
let enabled = Boolean(level);

const maybeLevel: SupportLevel|undefined = ...;
enabled = !!maybeLevel;
```

```typescript
// ✅ ХОРОШО

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
let enabled = level !== SupportLevel.NONE;

const maybeLevel: SupportLevel|undefined = ...;
enabled = level !== undefined && level !== SupportLevel.NONE;
```

<Callout
  type="info"
  emoji="ℹ️"
>
Почему?

Для большинства задач не имеет значения, числовое или строковое значение сопоставлено с именем перечисления во время выполнения программы, поскольку значения перечислений указываются в исходном коде по имени. Следовательно, инженеры привыкли не задумываться об этом, а потому нежелательны ситуации, когда это действительно важно, так как они будут приводить к неожиданностям. Так происходит и в случае преобразования перечислений в булевы значения; в частности, вероятно может быть неожиданным, что по умолчанию первое объявленное значение перечисления является ложным (потому что оно равно 0), в то время как остальные значения являются истинными. Пользователи, читающие код, в котором используется значение перечисления, могут даже не знать, является ли оно первым объявленным значением или нет.

</Callout>

Не приветствуется для приведения к строке использовать конкатенацию строк, так как при проверке кода мы отслеживаем, чтобы операнды оператора "плюс" имели совпадающие типы.

Код _должен_ использовать `Number()` для парсинга числовых значений и _должен_ явно проверять его возврат на значения `NaN`, за исключением случаев, когда из контекста точно известно, что сбой парсинга невозможен.

<Callout
  type="info"
  emoji="ℹ️"
>
  Примечание: `Number('')`, `Number(' ')`, и `Number('\t')` могут вернуть `0`
  вместо `NaN`. `Number('Infinity')` и `Number('-Infinity')` могут вернуть
  `Infinity` и `-Infinity` соответственно. Кроме того, экспоненциальная запись,
  такая как `Number('1e+309')` и `Number('-1e+309')`, может привести к
  переполнению и преобразованию в `Infinity`. Подобные случаи могут потребовать
  особого обращения.
</Callout>

```typescript
// ✅ ХОРОШО

const aNumber = Number('123');
if (!isFinite(aNumber)) throw new Error(...);
```

В коде _не должен_ использоваться унарный плюс (`+`) для преобразования строки в число. Парсинг чисел может привести к неудаче, иметь неожиданные исключительные ситуации и может быть признаком дурно пахнущего кода (парсинг чисел не на том уровне). Учитывая это, унарный плюс слишком легко пропустить при проверке кода.

```typescript
// ❌ ПЛОХО

const x = +y;
```

В коде также _не должны_ использоваться `parseInt` или `parseFloat` для парсинга чисел, за исключением случаев парсинга в строках недесятичных числовых значений (см. ниже). Обе эти функции игнорируют конечные символы в строке, что может привести к возникновению ошибочного состояния (например, парсинг `12 гномов` как `12`).

```typescript
// ❌ ПЛОХО

const n = parseInt(someString, 10); // Подвержено ошибкам,
const f = parseFloat(someString); // независимо от передачи основания системы счисления.
```

Код, требующий выполнить парсинг числа с указанием системы счисления, перед вызовом `parseInt` _должен_ проверить, что входные данные содержат только подходящие для этой системы счисления цифры;

```typescript
// ✅ ХОРОШО

if (!/^[a-fA-F0-9]+$/.test(someString)) throw new Error(...);
// Требуется для парсинга восьмеричного числа.
const n = parseInt(someString, 16);  // Допустимо только для основания числа != 10
```

Используйте `Number()`, а затем `Math.floor` или `Math.trunc` (там, где это возможно) для парсинга целых чисел:

```typescript
// ✅ ХОРОШО

let f = Number(someString);
if (isNaN(f)) handleError();
f = Math.floor(f);
```

**Неявное преобразование типов**

Не используйте явное логическое преобразование в условиях, в которых уже имеется неявное логическое преобразование. Это условия в операторах `if`, `for` и `while`.

```typescript
// ❌ ПЛОХО

const foo: MyInterface|null = ...;
if (!!foo) {...}
while (!!foo) {...}
```

```typescript
// ✅ ХОРОШО

const foo: MyInterface|null = ...;
if (foo) {...}
while (foo) {...}
```

[Как и в случае явных преобразований](), значения перечислений (включая объединения перечислений и других типов) _не должны_ неявно приводиться к логическим значениям, а должны сравниваться явным образом с помощью операторов сравнения.

```typescript
// ❌ ПЛОХО

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
if (level) {...}

const maybeLevel: SupportLevel|undefined = ...;
if (level) {...}
```

```typescript
// ✅ ХОРОШО

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
if (level !== SupportLevel.NONE) {...}

const maybeLevel: SupportLevel|undefined = ...;
if (level !== undefined && level !== SupportLevel.NONE) {...}
```

Другие типы значений могут быть либо неявно преобразованы в логические значения, либо явно сравнены с помощью операторов сравнения:

```typescript
// ✅ ХОРОШО

// Явное сравнение > 0 это хорошо:
if (arr.length > 0) {...}
// так же как и полагаться на неявное булево преобразование:
if (arr.length) {...}
```

### 4.9 Структуры управления

#### 4.9.1 Операторы и блоки потока управления

**Итерация контейнеров**

Для итерации по массивам предпочтительно использовать `for (... of someArr)`. Также приемлемо использовать `Array.prototype.forEach` или обычные циклы `for`:

```typescript
// ✅ ХОРОШО

for (const x of someArr) {
  // x - ссылается на значение из someArr
}

for (let i = 0; i < someArr.length; i++) {
  // Если необходим индекс, то используйте явный пересчет, а иначе используйте форму for/of.
  const x = someArr[i];
  // ...
}
for (const [i, x] of someArr.entries()) {
  // Альтернативная версия предыдущего.
}
```

Не используйте `for (... in ...)` для итерации по массивам. Это будет контринтуитивно давать индексы массива (в виде строк!), а не значения:

```typescript
// ❌ ПЛОХО

for (const x in someArray) {
  // x - это индекс!
}
```

`Object.prototype.hasOwnProperty` следует использовать в циклах `for`-`in`, чтобы исключить нежелательные свойства прототипа. Если это возможно, отдавайте предпочтение `for`-`of` с `Object.keys`, `Object.values` или `Object.entries` вместо `for`-`in`.

```typescript
// ✅ ХОРОШО

for (const key in obj) {
  if (!obj.hasOwnProperty(key)) continue;
  doWork(key, obj[key]);
}
for (const key of Object.keys(obj)) {
  doWork(key, obj[key]);
}
for (const value of Object.values(obj)) {
  doWorkValOnly(value);
}
for (const [key, value] of Object.entries(obj)) {
  doWork(key, value);
}
```

#### 4.9.3 Обработка исключений

Исключения — важная часть языка, и их следует использовать всякий раз, когда возникают исключительные случаи.

Пользовательские исключения предоставляют отличный способ передать дополнительную информацию об ошибках из функций. Их следует определить и использовать там, где встроенного типа `Error` недостаточно.

Предпочитайте создание исключений, а не специальные подходы к обработке ошибок (например, передачу ссылочного типа контейнера ошибок или возврат объекта со свойством ошибки).

**Использование `new` при создании экземпляров класса `Error`**

Всегда используйте `new Error()` при создании исключений вместо простого вызова `Error()`. В обоих случаях создается новый экземпляр `Error`, но использование `new` более согласуется с тем, как создаются экземпляры других объектов.

```typescript
// ✅ ХОРОШО

throw new Error('Foo is not a valid bar.');
```

```typescript
// ❌ ПЛОХО

throw Error('Foo is not a valid bar.');
```

**При выбрасывании исключений используйте только экземпляры класса `Error`**

JavaScript (и, следовательно, TypeScript) позволяет при выбрасывании исключений использовать произвольные значения. Однако если выброшенное значение не является экземпляром класса Error, то оно не получит записи трассировки стека, что затруднит отладку. Эта обработка распространяется на значения отклонения `Promise`, поскольку `Promise.reject(obj)` эквивалентен `throw obj;` в асинхронных функциях.

```typescript
// ❌ ПЛОХО

// плохо: не позволяет получить трассировку стека.
throw 'oh noes!';
// Для Promise
new Promise((resolve, reject) => void reject('oh noes!'));
Promise.reject();
Promise.reject('oh noes!');
```

Вместо этого, при выбрасывании исключений используйте только экземпляры класса (или подкласса) `Error`:

```typescript
// ✅ ХОРОШО

// При выбрасывании исключений используйте только экземпляры класса Error
throw new Error('oh noes!');
// ... или подтипы класса Error
class MyError extends Error {}
throw new MyError('my oh noes!');
// Для Promise
new Promise((resolve) => resolve()); // Нет отказа – это нормально.
new Promise((resolve, reject) => void reject(new Error('oh noes!')));
Promise.reject(new Error('oh noes!'));
```

**Перехват и проброс исключений**

В коде, при перехвате исключений, _рекомендуется_ рассматривать все бросаемые исключения как экземпляры класса `Error`.

```typescript
// ✅ ХОРОШО

function assertIsError(e: unknown): asserts e is Error {
  if (!(e instanceof Error)) throw new Error('e is not an Error');
}

try {
  doSomething();
} catch (e: unknown) {
  // Все выбрасываемые исключения должны быть подтипами класса Error. Не обрабатывайте другие
  // возможные значения, кроме случаев, когда вы точно знаете, что именно они будут выброшены.
  assertIsError(e);
  displayError(e.message);
  // или проброс
  throw e;
}
```

Обработчики исключений _не должны_ защитно обрабатывать типы, отличные от `Error`, за исключением случаев, когда достоверно известно, что вызываемый API выбрасывает исключения, не соответствующие типу `Error`, в нарушение вышеуказанного правила. В таком случае рекомендуется добавить комментарий, в котором специально указывается источник возникновения исключения, не соответствующего типу `Error`.

```typescript
// ✅ ХОРОШО

try {
  badApiThrowingStrings();
} catch (e: unknown) {
  // Примечание: это плохое API при выбрасывании исключения передает строку, вместо экземпляра класса Error
  if (typeof e === 'string') { ... }
}
```

<Callout
  type="info"
  emoji="ℹ️"
>
Почему?

Избегайте чрезмерно защитного программирования. Повторение одних и тех же защитных средств от проблемы, которой не будет существовать в большей части кода, приводит к появлению шаблонного кода, который не является полезным.

</Callout>

### 4.11 Запрещенные функции

#### 4.11.1 Примитивные типы & Классы-обертки

Код TypeScript _не должен_ создавать экземпляры классов-оберток для примитивных типов `String`, `Boolean` и `Number`. Классы-обертки имеют неожиданное поведение, такое как new `Boolean(false)` равное `true`.

```typescript
// ❌ ПЛОХО

const s = new String('hello');
const b = new Boolean(false);
const n = new Number(5);
```

```typescript
// ✅ ХОРОШО

const s = 'hello';
const b = false;
const n = 5;
```

Обертки можно вызывать как функции для приведения (что предпочтительнее использования `+` или объединения пустой строки) или создания символов. Дополнительную информацию см. в [разделе "Приведение типов"]().

## 5 Именование

### 5.1 Идентификаторы

Идентификаторы _должны_ использовать только ASCII символы, цифры, символы подчеркивания (для констант и названий методов структурных тестов) и знак `$`. Таким образом, каждое допустимое имя идентификатора соответствует регулярному выражению `[$\w]+`.

#### 5.1.1 Стиль именования

TypeScript отражает информацию в типах, поэтому имена _не рекомендуется_ дополнять информацией, которая включена в тип.

Несколько конкретных примеров для этого правила:

- Не используйте начальные или завершащие символы подчеркивания для приватных свойств или методов.
- Не используйте префикс `opt_` для необязательных параметров.
  - Для аксессоров, см. ниже [правила использования аксессоров]().
- Не стоит специально помечать интерфейсы (~~`IMyInterface`~~ или ~~`MyFooInterface`~~), если только они не идиоматичны в своей среде. Когда вы вводите интерфейс для класса, дайте ему имя, которое выражает причину существования интерфейса (например, `class TodoItem` и `interface TodoItemStorage` если интерфейс выражает формат, используемый для хранения/сериализации в JSON).
- Добавление к наблюдаемым элементам (`Observable`) суффикса `$` является распространенным внешним соглашением и может помочь устранить путаницу между наблюдаемыми и конкретными значениями. Решение о том, является ли это полезным соглашением, остается на усмотрение отдельных команд, но _рекомендуется_, чтобы оно было согласованным в рамках проектов.

#### 5.1.2 Описательные названия

Названия _должны_ быть описательными и ясными для новых читателей. Не используйте аббревиатуры, которые могут быть незнакомыми или двусмысленными для читателей за пределами вашего проекта и не сокращайте, удаляя в словах буквы.

- **Исключение**: Для переменных, область действия которых составляет не более 10 строк, включая аргументы, которые _не_ являются частью экспортируемого API, _возможно_ использование коротких (например, однобуквенных) имен переменных.

```typescript
// ✅ ХОРОШО

// Хорошие идентификаторы:
errorCount; // Без сокращений.
dnsConnectionIndex; // Большинство людей знают, что означает «DNS».
ReferrerUrl; // То же самое для «URL».
customerId; // «Id» встречается повсеместно и вряд ли будет понят неправильно.
```

```typescript
// ❌ ПЛОХО

// Запрещенные идентификаторы:
n; // Бессмысленно.
nErr; // Неоднозначное сокращение.
nCompConns; // Неоднозначное сокращение.
wgcConnections; // Только ваша группа знает, что это означает.
pcReader; // Многие вещи можно сократить до «ПК».
cstmrId; // Удаляет внутренние буквы.
kSecondsPerDay; // Не используйте венгерскую нотацию.
customerID; // Неправильный регистр "ID".
```

#### 5.1.3 Верблюжий регистр (Camel case)

Рассматривайте используемые в именах аббревиатуры типа акронимов как целые слова, т.е. используйте `loadHttpUrl`, а не ~~`loadHTTPURL`~~, если только это не обусловлено названием конкретной платформы (например `XMLHttpRequest`).

#### 5.1.4 Знак доллара

В идентификаторах, как правило, _не рекомендуется_ использовать символ `$`, за исключением случаев, когда это соответствуют соглашениям об именовании для сторонних фреймворков. Подробнее об использовании суффикса `$` для наблюдаемых (`Observable`) значений [см. ниже]().

### 5.2 Правила по типу идентификатора

| Стиль            | Категория                                                                                                                |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `UpperCamelCase` | класс / интерфейс / тип / перечисление / декоратор / параметры типа / функции компонента в параметре типа TSX/JSXElement |
| `lowerCamelCase` | переменная / параметр / функция / метод / свойство / псевдонимы модулей                                                  |
| `CONSTANT_CASE`  | глобальные константы, включая имена элементов перечислений (`enum`). См. ниже раздел [Константы](#константы)             |
| `#ident`         | подобные приватные идентификаторы не применяются                                                                         |

#### 5.2.1 Параметры типа

Для обозначения параметров типа, как например в `Array<T>`, _возможно_ использовать один символ верхнего регистра (`T`) или `UpperCamelCase`.

#### 5.2.2 Названия тестов

Название тестовых методов в Closure `testSuite` и подобных тестовых фреймворках в стиле xUnit _возможно_ представлять с разделителями `_`, например `testX_whenY_doesZ()`.

#### 5.2.3 `_` префикс/суффикс

Идентификаторы не должны использовать `_` в качестве префикса или суффикса.  
Это также означает что символ `_` сам по себе _не должен_ быть использован в качестве идентификатора (например, чтобы указать, что параметр не используется).

<Callout
  type="info"
  emoji="ℹ️"
>
  Cовет: Если вам нужны только некоторые элементы из массива (или TypeScript
  кортежа), вы можете вставить дополнительные запятые в выражение
  деструктуризации, чтобы игнорировать промежуточные элементы:
</Callout>

```typescript
// ✅ ХОРОШО

const [a, , b] = [1, 5, 10]; // a <- 1, b <- 10
```

#### 5.2.4 Импорты

Импорты пространств имен модулей пишутся в стиле `lowerCamelCase` в то время как файлы именуются в стиле `snake_case`, что означает, что корректные импорты не будут совпадать по стилю написания с именами файлов. Например:

```typescript
// ✅ ХОРОШО

import * as fooBar from './foo_bar';
```

Некоторые библиотеки могут широко использовать префиксы для импорта пространств имен, которые противоречат этой схеме именования, но их обширное использование в решениях с открытым исходным кодом делает этот нарушающий стиль более понятным. Единственными библиотеками, которые в настоящее время подпадают под это исключение, являются:

- **jquery**, использует `$` как префикс;
- **threejs**, использует `THREE` как префикс.

#### 5.2.5 Константы

**Иммутабельность**: Стиль `CONSTANT_CASE` указывает на то, что значение _предназначено_ быть неизменным и при этом такой стиль также _возможно_ использовать для значений, которые могут быть изменены технически (т.е. значений, которые не являются глубоко замороженными), чтобы явно указать пользователям на то, что эти значения нельзя изменять.

```typescript
// ✅ ХОРОШО

const UNIT_SUFFIXES = {
  milliseconds: 'ms',
  seconds: 's',
};
// Несмотря на то, что в соответствии с правилами JavaScript UNIT_SUFFIXES является изменяемым,
// верхний регистр символов обозначает для пользователей, что они не должны изменять значения.
```

Константой также может быть статическое свойство класса, которое предназначенно только для чтения (`static readonly`).

```typescript
// ✅ ХОРОШО

class Foo {
  private static readonly MY_SPECIAL_NUMBER = 5;

  bar() {
    return 2 * Foo.MY_SPECIAL_NUMBER;
  }
}
```

**Глобальность**: Только для элементов, объявленных на уровне модуля, статических полей классов уровня модуля и значений перечислений уровня модуля _возможно_ использовать `CONST_CASE` стиль. Если во время работы программы значение создается более одного раза (например, локальная переменная, объявленная в функции или статическое поле в классе, вложенном в функцию), тогда _должен_ использоваться `lowerCamelCase` стиль.

Если значение представляет собой стрелочную функцию которая реализует интерфейс, тогда это _возможно_ объявлять в `lowerCamelCase` стиле.

#### 5.2.6 Псевдонимы

При создании локального псевдонима существующего элемента, используйте формат уже существующего его обозначения. Локальный псевдоним _должен_ совпадать с существующим именем и форматом источника. Для переменных при создании локальных псевдонимов используйте `const`, а для полей класса - атрибут `readonly`.

<Callout
  type="info"
  emoji="ℹ️"
>
  Примечание: Если вы создаете псевдоним только ради использования его для
  шаблона в выбранном вами фреймворке, не забудьте также назначить
  соответствующие [модификаторы доступа]().
</Callout>

```typescript
// ✅ ХОРОШО

const { BrewStateEnum } = SomeType;
const CAPACITY = 5;

class Teapot {
  readonly BrewStateEnum = BrewStateEnum;
  readonly CAPACITY = CAPACITY;
}
```
