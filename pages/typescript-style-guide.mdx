import { Callout } from 'nextra/components';

# TypeScript Style Guide

## Введение

Данное руководство основано на внутреннем руководстве Google по стилю написания кода на языке TypeScript, но при этом оно было незначительно скорректировано с целью удаления разделов предназначенных для внутреннего пользования Google. Внутренняя среда Google предусматривает иные ограничения на TypeScript, чем те, что вы могли бы встретить за пределами Google. Приведенные здесь советы особенно полезны для людей, создающих код, который они намерены импортировать в Google, однако в других случаях они могут и не применяться в вашей внешней по отношению к Google среде.

## Синтаксис

### Идентификаторы

Идентификаторы _должны_ использовать только ASCII символы, цифры, символы подчеркивания (для констант и названий методов структурных тестов) и знак `$`. Таким образом, каждое допустимое имя идентификатора соответствует регулярному выражению `[$\w]+`.

| Стиль            | Категория                                                                                                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------ |
| `UpperCamelCase` | класс / интерфейс / тип / перечисление / декоратор / параметр типа                                           |
| `lowerCamelCase` | переменная / параметр / функция / метод / свойство / псевдонимы модулей                                      |
| `CONSTANT_CASE`  | глобальные константы, включая имена элементов перечислений (`enum`). См. ниже раздел [Константы](#константы) |
| `#ident`         | подобные приватные идентификаторы не применяются                                                             |

#### Аббревиатуры

Рассматривайте используемые в именах аббревиатуры типа акронимов как целые слова, т.е. используйте `loadHttpUrl`, а не ~~`loadHTTPURL`~~, если только это не обусловлено названием конкретной платформы (например `XMLHttpRequest`).

#### Знак доллара

В идентификаторах, как правило, _не рекомендуется_ использовать символ `$`, за исключением случаев, когда это соответствуют соглашениям об именовании для сторонних фреймворков. Подробнее об использовании суффикса `$` для наблюдаемых (`Observable`) значений [см. ниже](#стиль-именования).

#### Параметры типа

Для обозначения параметров типа, как например в `Array<T>`, _возможно_ использовать один символ верхнего регистра (`T`) или `UpperCamelCase`.

#### Названия тестов

Название тестовых методов в Closure `testSuite` и подобных тестовых фреймворках в стиле xUnit _возможно_ представлять с разделителями `_`, например `testX_whenY_doesZ()`.

#### `_` префикс/суффикс

Идентификаторы не должны использовать `_` в качестве префикса или суффикса.  
Это также означает что символ `_` сам по себе _не должен_ быть использован в качестве идентификатора (например, чтобы указать, что параметр не используется).

<Callout
  type="info"
  emoji="ℹ️"
>
  Совет: Если вам нужны только некоторые элементы из массива (или TypeScript
  кортежа), вы можете вставить дополнительные запятые в выражение
  деструктуризации, чтобы игнорировать промежуточные элементы:
</Callout>

```ts
// ✅ ХОРОШО

const [a, , b] = [1, 5, 10]; // a <- 1, b <- 10
```

#### Импорты

Импорты пространств имен модулей пишутся в стиле `lowerCamelCase` в то время как файлы именуются в стиле `snake_case`, что означает, что корректные импорты не будут совпадать по стилю написания с именами файлов. Например:

```ts
// ✅ ХОРОШО

import * as fooBar from './foo_bar';
```

Некоторые библиотеки могут широко использовать префиксы для импорта пространств имен, которые противоречат этой схеме именования, но их обширное использование в решениях с открытым исходным кодом делает этот нарушающий стиль более понятным. Единственными библиотеками, которые в настоящее время подпадают под это исключение, являются:

- [jquery](https://jquery.com), использует `$` как префикс;
- [threejs](https://threejs.org), использует `THREE` как префикс.

#### Константы

**Иммутабельность**: Стиль `CONSTANT_CASE` указывает на то, что значение _предназначено_ быть неизменным и при этом такой стиль также _возможно_ использовать для значений, которые могут быть изменены технически (т.е. значений, которые не являются глубоко замороженными), чтобы явно указать пользователям на то, что эти значения нельзя изменять.

```ts
// ✅ ХОРОШО

const UNIT_SUFFIXES = {
  milliseconds: 'ms',
  seconds: 's',
};
// Несмотря на то, что в соответствии с правилами JavaScript UNIT_SUFFIXES является изменяемым,
// верхний регистр символов обозначает для пользователей, что они не должны изменять значения.
```

Константой также может быть статическое свойство класса, которое предназначенно только для чтения (`static readonly`).

```ts
// ✅ ХОРОШО

class Foo {
  private static readonly MY_SPECIAL_NUMBER = 5;

  bar() {
    return 2 * Foo.MY_SPECIAL_NUMBER;
  }
}
```

**Глобальность**: Только для элементов, объявленных на уровне модуля, статических полей классов уровня модуля и значений перечислений уровня модуля _возможно_ использовать `CONST_CASE` стиль. Если во время работы программы значение создается более одного раза (например, локальная переменная, объявленная в функции или статическое поле в классе, вложенном в функцию), тогда _должен_ использоваться `lowerCamelCase` стиль.

Если значение представляет собой стрелочную функцию которая реализует интерфейс, тогда это _возможно_ объявлять в `lowerCamelCase` стиле.

#### Псевдонимы

При создании локального псевдонима существующего элемента, используйте формат уже существующего его обозначения. Локальный псевдоним _должен_ совпадать с существующим именем и форматом источника. Для переменных при создании локальных псевдонимов используйте `const`, а для полей класса - атрибут `readonly`.

<Callout
  type="info"
  emoji="ℹ️"
>
  Примечание: Если вы создаете псевдоним только ради использования его для
  шаблона в выбранном вами фреймворке, не забудьте также назначить
  соответствующие [модификаторы
  доступа](#свойства-используемые-за-пределами-лексической-области-класса).
</Callout>

```ts
// ✅ ХОРОШО

const { BrewStateEnum } = SomeType;
const CAPACITY = 5;

class Teapot {
  readonly BrewStateEnum = BrewStateEnum;
  readonly CAPACITY = CAPACITY;
}
```

#### Стиль именования

TypeScript отражает информацию в типах, поэтому имена _не рекомендуется_ дополнять информацией, которая включена в тип (см. также [Блог о тестировании (Testing Blog)](https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html) для получения дополнительной информации о том, что не следует включать).

Несколько конкретных примеров для этого правила:

- Не используйте начальные или завершащие символы подчеркивания для приватных свойств или методов.
- Не используйте префикс `opt_` для необязательных параметров.
  - Для аксессоров, см. ниже [правила использования аксессоров](#геттеры-и-сеттеры-аксессоры).
- Не стоит специально помечать интерфейсы (~~`IMyInterface`~~ или ~~`MyFooInterface`~~), если только они не идиоматичны в своей среде. Когда вы вводите интерфейс для класса, дайте ему имя, которое выражает причину существования интерфейса (например, `class TodoItem` и `interface TodoItemStorage` если интерфейс выражает формат, используемый для хранения/сериализации в JSON).
- Добавление к наблюдаемым элементам (`Observable`) суффикса `$` является распространенным внешним соглашением и может помочь устранить путаницу между наблюдаемыми и конкретными значениями. Решение о том, является ли это полезным соглашением, остается на усмотрение отдельных команд, но _рекомендуется_, чтобы оно было согласованным в рамках проектов.

#### Описательные названия

Названия _должны_ быть описательными и ясными для новых читателей. Не используйте аббревиатуры, которые могут быть незнакомыми или двусмысленными для читателей за пределами вашего проекта и не сокращайте, удаляя в словах буквы.

- **Исключение**: Для переменных, область действия которых составляет не более 10 строк, включая аргументы, которые _не_ являются частью экспортируемого API, _возможно_ использование коротких (например, однобуквенных) имен переменных.

### Кодировка файлов: UTF-8

Для символов, отличных от ASCII, используйте фактический символ Юникода (например `∞`). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например `\u221e`) вместе с пояснительным комментарием.

```ts
// ✅ ХОРОШО

// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
```

```ts
// ❌ ПЛОХО

// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
```
