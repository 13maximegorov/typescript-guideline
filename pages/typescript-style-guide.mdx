import { Callout } from 'nextra/components';

# TypeScript Style Guide

## Введение

Данное руководство основано на внутреннем руководстве Google по стилю написания кода на языке TypeScript, но при этом оно было незначительно скорректировано с целью удаления разделов предназначенных для внутреннего пользования Google. Внутренняя среда Google предусматривает иные ограничения на TypeScript, чем те, что вы могли бы встретить за пределами Google. Приведенные здесь советы особенно полезны для людей, создающих код, который они намерены импортировать в Google, однако в других случаях они могут и не применяться в вашей внешней по отношению к Google среде.

## Синтаксис

### Идентификаторы

Идентификаторы _должны_ использовать только ASCII символы, цифры, символы подчеркивания (для констант и названий методов структурных тестов) и знак `$`. Таким образом, каждое допустимое имя идентификатора соответствует регулярному выражению `[$\w]+`.

| Стиль            | Категория                                                                                                    |
| ---------------- | ------------------------------------------------------------------------------------------------------------ |
| `UpperCamelCase` | класс / интерфейс / тип / перечисление / декоратор / параметр типа                                           |
| `lowerCamelCase` | переменная / параметр / функция / метод / свойство / псевдонимы модулей                                      |
| `CONSTANT_CASE`  | глобальные константы, включая имена элементов перечислений (`enum`). См. ниже раздел [Константы](#константы) |
| `#ident`         | подобные приватные идентификаторы не применяются                                                             |

#### Аббревиатуры

Рассматривайте используемые в именах аббревиатуры типа акронимов как целые слова, т.е. используйте `loadHttpUrl`, а не ~~`loadHTTPURL`~~, если только это не обусловлено названием конкретной платформы (например `XMLHttpRequest`).

#### Знак доллара

В идентификаторах, как правило, _не рекомендуется_ использовать символ `$`, за исключением случаев, когда это соответствуют соглашениям об именовании для сторонних фреймворков. Подробнее об использовании суффикса `$` для наблюдаемых (`Observable`) значений [см. ниже](#стиль-именования).

#### Параметры типа

Для обозначения параметров типа, как например в `Array<T>`, _возможно_ использовать один символ верхнего регистра (`T`) или `UpperCamelCase`.

#### Названия тестов

Название тестовых методов в Closure `testSuite` и подобных тестовых фреймворках в стиле xUnit _возможно_ представлять с разделителями `_`, например `testX_whenY_doesZ()`.

#### `_` префикс/суффикс

Идентификаторы не должны использовать `_` в качестве префикса или суффикса.  
Это также означает что символ `_` сам по себе _не должен_ быть использован в качестве идентификатора (например, чтобы указать, что параметр не используется).

<Callout
  type="info"
  emoji="ℹ️"
>
  Совет: Если вам нужны только некоторые элементы из массива (или TypeScript
  кортежа), вы можете вставить дополнительные запятые в выражение
  деструктуризации, чтобы игнорировать промежуточные элементы:
</Callout>

```ts
// ✅ ХОРОШО

const [a, , b] = [1, 5, 10]; // a <- 1, b <- 10
```

#### Импорты

Импорты пространств имен модулей пишутся в стиле `lowerCamelCase` в то время как файлы именуются в стиле `snake_case`, что означает, что корректные импорты не будут совпадать по стилю написания с именами файлов. Например:

```ts
// ✅ ХОРОШО

import * as fooBar from './foo_bar';
```

Некоторые библиотеки могут широко использовать префиксы для импорта пространств имен, которые противоречат этой схеме именования, но их обширное использование в решениях с открытым исходным кодом делает этот нарушающий стиль более понятным. Единственными библиотеками, которые в настоящее время подпадают под это исключение, являются:

- [jquery](https://jquery.com), использует `$` как префикс;
- [threejs](https://threejs.org), использует `THREE` как префикс.

#### Константы

**Иммутабельность**: Стиль `CONSTANT_CASE` указывает на то, что значение _предназначено_ быть неизменным и при этом такой стиль также _возможно_ использовать для значений, которые могут быть изменены технически (т.е. значений, которые не являются глубоко замороженными), чтобы явно указать пользователям на то, что эти значения нельзя изменять.

```ts
// ✅ ХОРОШО

const UNIT_SUFFIXES = {
  milliseconds: 'ms',
  seconds: 's',
};
// Несмотря на то, что в соответствии с правилами JavaScript UNIT_SUFFIXES является изменяемым,
// верхний регистр символов обозначает для пользователей, что они не должны изменять значения.
```

Константой также может быть статическое свойство класса, которое предназначенно только для чтения (`static readonly`).

```ts
// ✅ ХОРОШО

class Foo {
  private static readonly MY_SPECIAL_NUMBER = 5;

  bar() {
    return 2 * Foo.MY_SPECIAL_NUMBER;
  }
}
```

**Глобальность**: Только для элементов, объявленных на уровне модуля, статических полей классов уровня модуля и значений перечислений уровня модуля _возможно_ использовать `CONST_CASE` стиль. Если во время работы программы значение создается более одного раза (например, локальная переменная, объявленная в функции или статическое поле в классе, вложенном в функцию), тогда _должен_ использоваться `lowerCamelCase` стиль.

Если значение представляет собой стрелочную функцию которая реализует интерфейс, тогда это _возможно_ объявлять в `lowerCamelCase` стиле.

#### Псевдонимы

При создании локального псевдонима существующего элемента, используйте формат уже существующего его обозначения. Локальный псевдоним _должен_ совпадать с существующим именем и форматом источника. Для переменных при создании локальных псевдонимов используйте `const`, а для полей класса - атрибут `readonly`.

<Callout
  type="info"
  emoji="ℹ️"
>
  Примечание: Если вы создаете псевдоним только ради использования его для
  шаблона в выбранном вами фреймворке, не забудьте также назначить
  соответствующие [модификаторы
  доступа](#свойства-используемые-за-пределами-лексической-области-класса).
</Callout>

```ts
// ✅ ХОРОШО

const { BrewStateEnum } = SomeType;
const CAPACITY = 5;

class Teapot {
  readonly BrewStateEnum = BrewStateEnum;
  readonly CAPACITY = CAPACITY;
}
```

#### Стиль именования

TypeScript отражает информацию в типах, поэтому имена _не рекомендуется_ дополнять информацией, которая включена в тип (см. также [Блог о тестировании (Testing Blog)](https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html) для получения дополнительной информации о том, что не следует включать).

Несколько конкретных примеров для этого правила:

- Не используйте начальные или завершащие символы подчеркивания для приватных свойств или методов.
- Не используйте префикс `opt_` для необязательных параметров.
  - Для аксессоров, см. ниже [правила использования аксессоров](#геттеры-и-сеттеры-аксессоры).
- Не стоит специально помечать интерфейсы (~~`IMyInterface`~~ или ~~`MyFooInterface`~~), если только они не идиоматичны в своей среде. Когда вы вводите интерфейс для класса, дайте ему имя, которое выражает причину существования интерфейса (например, `class TodoItem` и `interface TodoItemStorage` если интерфейс выражает формат, используемый для хранения/сериализации в JSON).
- Добавление к наблюдаемым элементам (`Observable`) суффикса `$` является распространенным внешним соглашением и может помочь устранить путаницу между наблюдаемыми и конкретными значениями. Решение о том, является ли это полезным соглашением, остается на усмотрение отдельных команд, но _рекомендуется_, чтобы оно было согласованным в рамках проектов.

#### Описательные названия

Названия _должны_ быть описательными и ясными для новых читателей. Не используйте аббревиатуры, которые могут быть незнакомыми или двусмысленными для читателей за пределами вашего проекта и не сокращайте, удаляя в словах буквы.

- **Исключение**: Для переменных, область действия которых составляет не более 10 строк, включая аргументы, которые _не_ являются частью экспортируемого API, _возможно_ использование коротких (например, однобуквенных) имен переменных.

### Кодировка файлов: UTF-8

Для символов, отличных от ASCII, используйте фактический символ Юникода (например `∞`). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например `\u221e`) вместе с пояснительным комментарием.

```ts
// ✅ ХОРОШО

// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
```

```ts
// ❌ ПЛОХО

// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
```

### Не используйте продолжения строк

Не используйте _продолжения строк_ (т.е. завершение строки внутри строкового литерала обратным слешем) ни в обычных, ни в шаблонных строковых литералах. Хотя ES5 и позволяет использовать продолжения строк, этот функционал является менее очевидным для читателей, а также может привести к неожиданным ошибкам, если любой пробельный символ стоит после косой черты.

Запрещено:

{/* prettier-ignore */}
```ts
// ❌ ПЛОХО

const LONG_STRING = 'Это очень длинная строка, которая превышает лимит в \
    80 символов. К сожалению, она содержит длинные отрезки пустого пространства, так \
    как в продолженных строках имеются отступы для поддержания форматирования.';
```

Вместо этого напишите:

{/* prettier-ignore */}
```ts
// ✅ ХОРОШО

const LONG_STRING = 'Это очень длинная строка, которая превышает лимит в ' +
    '80 символов. Она не содержит длинные отрезки пустого пространства, поскольку ' +
    'конкатенируемые строки не имеют в себе лишних отступов.';
```

### Комментарии & Документация

#### Использование JSDoc в сравнении с обычными комментариями

Существует два типа комментариев, JSDoc (`/** ... */`) и не относящиеся к JSDoc обычные комментарии (`// ...` или `/* ... */`).

- Используйте `/** JSDoc */` комментарии для документации. Это те комментарии, с которыми стоит ознакомиться при использовании кода.
- Используйте `// строчные комментарии` для комментирования реализации. Эти комментарии которые касаются только реализации самого кода.

Комментарии JSDoc могут распознаваться различными инструментальными программами, такими как редакторы кода и генераторы документации, в то время как обычные комментарии могут быть распознаны только другими людьми.

#### Правила JSDoc соответствуют стилю языка JavaScript

В общих чертах, следуйте [правилам для JSDoc из руководства по стилю написания JavaScript](https://google.github.io/styleguide/jsguide.html#jsdoc), разделы 7.1 - 7.5. В остальной части этого раздела описываются исключения из этих правил.

#### Документирование всех экспортов верхнего уровня в составе модулей

Используйте `/** JSDoc */` комментарии для передачи информации пользователям вашего кода. Избегайте простого повторения имени свойства или параметра. Вам _рекомендуется_ документировать все свойства и методы (экспортируемые/публичные или нет), назначение которых, по мнению вашего рецензента, не сразу очевидно из их названия.

Исключение: элементы, которые экспортируются только для использования инструментальными программами, например классы @NgModule, не требуют комментариев.

#### Исключите те комментарии, которые излишни в TypeScript

Для примера, не указывайте типы в `@param` или `@return` блоках, не пишите `@implements`, `@enum`, `@private`, `@override` в коде, который использует `implements`, `enum`, `private`, `override` и пр. ключевые слова.

#### Делайте комментарии, которые действительно добавляют информацию

Для неэкспортируемых элементов иногда достаточно имени и типа функции или параметра. Хотя код _обычно_ выигрывает от большего документирования, чем просто имена переменных!

- Избегайте комментариев в которых просто повторяется имя и тип параметра.

  ```ts
  // ❌ ПЛОХО

  /** @param fooBarService Сервис "The Bar" для приложения "the Foo". */
  ```

- Исходя из этого правила, строки `@param` и `@return` требуются только тогда, когда они добавляют новую информацию, а иначе их _возможно_ исключить.

  ```ts
  // ✅ ХОРОШО

  /**
   * Отправляет POST-запрос для начала варки кофе.
   * @param amountLitres Количество для заваривания. Должно соответствовать размеру емкости!
   */
  brew(amountLitres: number, logger: Logger) {
    // ...
  }
  ```

#### Комментарии к параметризованным свойствам

[Параметризованное свойство](https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties) — это параметр конструктора, которому предшествует один из модификаторов `private`, `protected`, `public` или `readonly`. Параметризованное свойство объявляет одновременно и параметр и свойство экземпляра, а также неявно присваивает им значения. Для примера, выражение `constructor(private readonly foo: Foo)` объявляет то, что конструктор принимает параметр `foo`, а также объявляет приватное и доступное только для чтения свойство `foo` и присваивает значение параметра этому свойству перед выполнением остальной части конструктора.

Чтобы задокументировать эти поля, используйте JSDoc `@param` аннотацию. Редакторы отображают описание при вызовах конструктора и доступе к свойствам.

```ts
// ✅ ХОРОШО

/** Этот класс демонстрирует, как документируются параметризованные свойства. */
class ParamProps {
  /**
   * @param percolator Кофеварка, используемая для варки.
   * @param beans Зерна для варки.
   */
  constructor(
    private readonly percolator: Percolator,
    private readonly beans: CoffeeBean[],
  ) {}
}
```

```ts
// ✅ ХОРОШО

/** Этот класс демонстрирует, как документируются обычные поля. */
class OrdinaryClass {
  /** Кофейные зерна, которые будут использоваться в следующем вызове brew(). */
  nextBean: CoffeeBean;

  constructor(initialBean: CoffeeBean) {
    this.nextBean = initialBean;
  }
}
```

#### Комментарии при вызове функции

При необходимости, документируйте параметры в местах вызова при помощи встраивания блочных комментариев. Также рассмотрите возможность применения именованных параметров с использованием объектного литерала и деструктуризации. При этом нет каких-либо четких правил касательно точного форматирования и размещения комментария.

```ts
// ✅ ХОРОШО

// Встраивание блочных комментариев для параметров, которые трудны для понимания:
new Percolator().brew(/* amountLitres= */ 5);
// Также рассмотрите возможность использования именованных аргументов и деструктуризации параметров (в объявлении метода "brew"):
new Percolator().brew({ amountLitres: 5 });
```

```ts
// ✅ ХОРОШО

/** Перколятор, как старый вариант кофеварки {@link CoffeeBrewer} */
export class Percolator implements CoffeeBrewer {
  /**
   * Сварить кофе.
   * @param amountLitres Количество, которое надо сварить. Должно соответствовать объему кофейника!
   */
  brew(amountLitres: number) {
    // Так или иначе, эта реализация создает ужасный кофе.
    // TODO(b/12345): Улучшить процесс варки кофе в кофеварке.
  }
}
```

#### Размещайте документацию перед декораторами

Когда класс, метод или свойство имеют и декораторы вида `@Component` и JSDoc, убедитесь, что JSDoc написан перед декоратором.

- Не пишите JSDoc между декоратором и декорируемым выражением.

  ```ts
  // ❌ ПЛОХО

  @Component({
    selector: 'foo',
    template: 'bar',
  })
  /** Компонент, который выводит "bar". */
  export class FooComponent {}
  ```

- Пишите блок с JSDoc перед декоратором.

  ```ts
  // ✅ ХОРОШО

  /** Компонент, который выводит "bar". */
  @Component({
    selector: 'foo',
    template: 'bar',
  })
  export class FooComponent {}
  ```

## Языковые правила

Возможности языка TypeScript, которые не рассматриваются в данном руководстве, _возможно_ использовать без каких-либо рекомендаций по их применению.
