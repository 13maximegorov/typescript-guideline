import { Callout } from 'nextra/components';

# TypeScript Style Guide

Оригинальное руководство по стилю от Google: [https://google.github.io/styleguide/tsguide.html](https://google.github.io/styleguide/tsguide.html).

## 2 Основы исходного файла

### 2.1 Кодировка файлов: UTF-8

Исходные файлы имеют кодировку **UTF-8**.

#### 2.1.3 Символы, отличные от ASCII

Для символов, отличных от ASCII, используйте фактический символ Юникода (например `∞`). Для непечатаемых символов можно использовать эквивалентный шестнадцатеричный код или экранирование Unicode-символов (например `\u221e`) вместе с пояснительным комментарием.

```typescript
// ✅ ХОРОШО

// Совершенно ясно даже без комментария
const units = 'μs';

// Используйте Unicode-экранирование для непечатаемых символов
const output = '\ufeff' + content; // это маркер последовательности байтов (Unicode BOM)
```

```typescript
// ❌ ПЛОХО

// Даже с комментарием, это сложно для чтения и подвержено потенциальным ошибкам.
const units = '\u03bcs'; // Греческая буква mu, 's'

// Читающий код не поймет, что это такое
const output = '\ufeff' + content;
```

## 4 Особенности языка

В этом разделе описывается, какие функции можно или нельзя использовать, а также любые дополнительные ограничения на их использование.

Возможности языка TypeScript, которые не рассматриваются в данном руководстве, возможно использовать без каких-либо рекомендаций по их применению.

### 4.1 Объявления локальных переменных

#### 4.1.1 Используйте const и let

Всегда используйте `const` или `let` для объявления переменных. По умолчанию используйте `const`, если не требуется переназначение переменной. Никогда не используйте `var`.

```typescript
// ✅ ХОРОШО

const foo = otherValue; // Используйте, если "foo" никогда не меняется.
let bar = someValue; // Используйте, если для "bar" когда-либо позднее будет присвоено значение
```

`const` и `let` имеют блочную область видимости, как и переменные в большинстве других языков. `var` в JavaScript ограничен областью действия функции, что может вызвать трудные для понимания ошибки. Не используйте его.

```typescript
// ❌ ПЛОХО

var foo = someValue; // Не используйте - область видимости var сложна и подвержена ошибкам.
```

Переменные _не должны_ использоваться до их объявления.

### 4.2 Литералы массива

#### 4.2.1 Не используйте `Array` конструктор

В коде на Typescript `не должен` использоваться `Array()` конструктор, с или без `new`. Его применение неоднозначно и сбивает с толку:

```typescript
// ❌ ПЛОХО

const a = new Array(2); // [undefined, undefined]
const b = new Array(2, 3); // [2, 3];
```

Вместо этого всегда используйте скобки для инициализации массивов или `from` для инициализации `Array` с определенным размером:

```typescript
// ✅ ХОРОШО

const a = [2];
const b = [2, 3];

// Эквивалент для Array(2):
const c = [];
c.length = 2;

// [0, 0, 0, 0, 0]
Array.from<number>({ length: 5 }).fill(0);
```

#### 4.2.3 Применение spread-оператора

Использование spread-оператора `[...foo]` является удобным сокращением для копирования или объединения итераций.

{/* prettier-ignore */}
```typescript
// ✅ ХОРОШО

const foo = [
  1,
];

const foo2 = [
  ...foo,
  6,
  7,
];

const foo3 = [
  5,
  ...foo,
];

foo2[1] === 6;
foo3[1] === 1;
```

При использовании spread-оператора раскладываемое значение _должно_ соответствовать создаваемому. При создании массива распределяйте только итерации. Примитивы, включая `null` и `undefined`, _не должны_ раскладываться.

```typescript
// ❌ ПЛОХО

const foo = [7];
const bar = [5, ...(shouldUseFoo && foo)]; // может быть undefined

// Создает {0: 'a', 1: 'b', 2: 'c'} но при этом не содержит длины (length)
const fooStrings = ['a', 'b', 'c'];
const ids = { ...fooStrings };
```

```typescript
// ✅ ХОРОШО

const foo = shouldUseFoo ? [7] : [];
const bar = [5, ...foo];
const fooStrings = ['a', 'b', 'c'];
const ids = [...fooStrings, 'd', 'e'];
```

### 4.3 Литералы объектов

#### 4.3.2 Итерация по объектам

Итерация по объектам с помощью `for (... in ...)` подвержена вероятным ошибкам, т.к. это включает в себя все перечисляемые свойства из цепочки прототипов.

Не используйте не фильтрованные `for (... in ...)` выражения:

```typescript
// ❌ ПЛОХО

for (const x in someObj) {
  // x может происходить от некоторого родительского прототипа!
}
```

Либо явно отфильтруйте значения с помощью оператора `if`, либо используйте `for (... of Object.keys(...))`.

{/* prettier-ignore */}
```typescript
// ✅ ХОРОШО

for (const x in someObj) {
  if (!someObj.hasOwnProperty(x)) continue;
  // сейчас x был точно определен в принадлежности someObj
}
for (const x of Object.keys(someObj)) { // примечание: for _of_!
  // сейчас x был точно определен в принадлежности someObj
}
for (const [key, value] of Object.entries(someObj)) { // примечание: for _of_!
  // сейчас key был точно определен в принадлежности someObj
}
```

### 4.4 Классы

#### 4.4.4 Конструкторы

При вызове конструктора всегда _должны_ использоваться скобки, даже если никакие аргументы не передаются:

{/* prettier-ignore */}
```typescript
// ❌ ПЛОХО

const x = new Foo;
```

```typescript
// ✅ ХОРОШО

const x = new Foo();
```

Отсутствие скобок может привести к тонким ошибкам. Эти две строки не эквивалентны:

```typescript
new Foo().Bar();
new Foo.Bar();
```

Нет необходимости предоставлять пустой конструктор или конструктор, который просто делегирует в родительский класс, поскольку ES2015 предоставляет конструктор класса по умолчанию, если он не указан. Однако _не рекомендуется_ убирать конструкторы с параметризованными свойствами, модификаторами области видимости или декораторами параметров, даже если тело конструктора пустое.

```typescript
// ❌ ПЛОХО

class UnnecessaryConstructor {
  constructor() {}
}
```

```typescript
// ❌ ПЛОХО

class UnnecessaryConstructorOverride extends Base {
  constructor(value: number) {
    super(value);
  }
}
```

```typescript
// ✅ ХОРОШО

class DefaultConstructor {}

class ParameterProperties {
  constructor(private myService) {}
}

class ParameterDecorators {
  constructor(@SideEffectDecorator myService) {}
}

class NoInstantiation {
  private constructor() {}
}
```

Конструктор должен быть отделен от окружающего кода сверху и снизу одной пустой строкой:

```typescript
// ✅ ХОРОШО

class Foo {
  myField = 10;

  constructor(private readonly ctorParam) {}

  doThing() {
    console.log(ctorParam.getThing() + myField);
  }
}
```

```typescript
// ❌ ПЛОХО

class Foo {
  myField = 10;
  constructor(private readonly ctorParam) {}
  doThing() {
    console.log(ctorParam.getThing() + myField);
  }
}
```

#### 4.4.5 Члены класса

**Не используйте приватные поля вида `#private`**

Не используйте приватные поля (также известные как приватные идентификаторы):

```typescript
// ❌ ПЛОХО

class Clazz {
  #ident = 1;
}
```

Вместо этого используйте поддерживаемые TypeScript аннотации видимости:

```typescript
// ✅ ХОРОШО

class Clazz {
  private ident = 1;
}
```

<Callout
  type="info"
  emoji="ℹ️"
>
Почему?

Приватные идентификаторы вызывают существенные проблемы с размером и производительностью при понижении версии стандарта ECMAScript, в которую будет скомпилирован код TypeScript и не поддерживаются до ES2015. Они могут быть понижены только до уровня ES2015, но не ниже. В то же время, они не дают существенных преимуществ, когда для контроля области видимости используется статическая проверка типов.

</Callout>

**Используйте модификатор `readonly`**

Пометьте модификатором `readonly` те свойства, которые никогда не переназначаются вне конструктора (они не обязательно должны быть глубоко неизменяемыми).

**Параметризованные свойства**

Вместо того чтобы просто передавать очевидный инициализатор в член класса, используйте [параметризованные свойства](https://www.typescriptlang.org/docs/handbook/2/classes.html#parameter-properties) TypeScript.

```typescript
// ❌ ПЛОХО

class Foo {
  private readonly barService: BarService;

  constructor(barService: BarService) {
    this.barService = barService;
  }
}
```

```typescript
// ✅ ХОРОШО

class Foo {
  constructor(private readonly barService: BarService) {}
}
```

Если параметризованное свойство нуждается в документировании, то [используйте JSDoc тег @param]().

**Инициализаторы полей**

Если элемент класса не является параметризованным свойством, инициализируйте его там, где он объявлен, что иногда позволяет совсем отбросить конструктор.

```typescript
// ❌ ПЛОХО

class Foo {
  private readonly userList: string[];

  constructor() {
    this.userList = [];
  }
}
```

```typescript
// ✅ ХОРОШО

class Foo {
  private readonly userList: string[] = [];
}
```

<Callout
  type="info"
  emoji="ℹ️"
>
  Совет: Свойства никогда не следует добавлять или удалять из экземпляра после
  завершения работы конструктора, поскольку это существенно ограничивает
  возможности виртуальных машин оптимизировать "форму" классов. Необязательные
  поля, которые могут быть заполнены позже, должны быть явно инициализированы
  как `undefined`, чтобы предотвратить последующие изменения формы.
</Callout>

**Свойства, используемые за пределами лексической области класса**

Для свойств, так или иначе задействованных вне лексической области видимости содержащего их класса, например, для свойств контроллера Angular используемых из шаблона, _не должна_ использоваться приватная (`private`) область видимости, т.к. к этим свойствам потребуется доступ за пределами лексической области видимости их класса.

Для этих свойств используйте либо `protected`, либо `public`, в зависимости от того, что подходит. Для свойств используемых в шаблонах Angular и AngularJS следует использовать `protected`, а в Polymer - `public`.

В TypeScript коде _не должны_ использоваться `obj['foo']` для обхода ограничения видимости свойства.

<Callout
  type="info"
  emoji="ℹ️"
>
Почему?

Когда свойство является приватным (`private`), вы объявляете автоматизированным системам и людям, что доступ к свойству ограничен методами объявленного класса, и они будут полагаться на это. Например, проверка на неиспользуемый код отметит приватное свойство, которое может посчитаться неиспользуемым, даже если какому-то коду из другого файла удастся обойти ограничение видимости.

Хотя это и кажется, что `obj['foo']` может обойти область видимости в компиляторе TypeScript, эта схема может быть нарушена путем изменения правил сборки, а также нарушается согласованность с оптимизациями.

</Callout>

**Геттеры и Сеттеры (Аксессоры)**

Для членов класса _возможно_ иcпользовать геттеры и сеттеры. Методы-геттеры _должны_ быть чистыми функциями (т.е. не иметь побочных эффектов и каждый раз возвращать одинаковый результат при одних и тех же параметрах). Они также полезны как средство ограничения видимости внутренних или подробных деталей реализации (показано ниже).

```typescript
// ✅ ХОРОШО

class Foo {
  constructor(private readonly someService: SomeService) {}

  get someMember(): string {
    return this.someService.someVariable;
  }

  set someMember(newValue: string) {
    this.someService.someVariable = newValue;
  }
}
```

```typescript
// ❌ ПЛОХО

class Foo {
  nextId = 0;
  get next() {
    return this.nextId++; // ПЛОХО: геттер меняет наблюдаемое состояние
  }
}
```

Если аксессор используется для сокрытия свойства класса, то для скрытого свойства _возможно_ указать префикс или суффикс с любым целым словом, например `internal` или `wrapped`. При использовании этих приватных свойств по возможности обращайтесь к их значению через аксессор. По крайней мере один аксессор к свойству _должен_ быть нетривиальным: не определяйте сквозные аксессоры только для того, чтобы скрыть свойство. Вместо этого сделайте свойство публичным (или подумайте о том, чтобы сделать его доступным только для чтения (`readonly`), чем просто определять геттер без сеттера).

```typescript
// ✅ ХОРОШО

class Foo {
  private wrappedBar = '';
  get bar() {
    return this.wrappedBar || 'bar';
  }

  set bar(wrapped: string) {
    this.wrappedBar = wrapped.trim();
  }
}
```

```typescript
// ❌ ПЛОХО

class Bar {
  private barInternal = '';
  // Ни один из этих аксессоров не имеет логики, поэтому просто сделайте bar публичным
  get bar() {
    return this.barInternal;
  }

  set bar(value: string) {
    this.barInternal = value;
  }
```

Геттеры и сеттеры _не должны_ определяться с помощью `Object.defineProperty`, поскольку это мешает переименованию свойств.

#### 4.4.6 Видимость

Ограничение видимости свойств, методов и целых типов помогает сохранить код слабо связанным.

- Максимально ограничивайте область видимости обозначений.
- Рассмотрите возможность преобразования приватных методов в неэкспортируемые функции в том же файле, но вне какого-либо класса, а также перемещение приватных свойств в отдельные, неэкспортируемые классы.
- В TypeScript все обозначения по умолчанию публичные. Никогда не используйте модификатор `public`, за исключением случаев объявления доступных для чтения и записи (т.е. не `readonly`) публичных параметризованных свойств (в конструкторе).

```typescript
// ❌ ПЛОХО

class Foo {
  public bar = new Bar(); // ПЛОХО: нет необходимости в модификаторе "public"

  constructor(public readonly baz: Baz) {} // ПЛОХО: модификатор "readonly" подразумевает, что это свойство имеет по умолчанию модификатор "public"
}
```

```typescript
// ✅ ХОРОШО

class Foo {
  bar = new Bar(); // ХОРОШО: нет необходимости в модификаторе "public"

  constructor(public baz: Baz) {} // допускается модификатор "public"
}
```

См. также [Область видимости экспортируемых элементов]() ниже.

### 4.5 Функции

#### 4.5.2 Предпочитайте объявления функций для именованных функций.

Предпочитайте `function foo() { ... }` для объявления именованных функций верхнего уровня.

```typescript
// ✅ ХОРОШО

function foo() {
  return 42;
}
```

```typescript
// ❌ ПЛОХО

const foo = () => 42;
```

Стрелочные функции верхнего уровня _возможно_ использовать, например, для обеспечения явной аннотации типа.

```typescript
// ✅ ХОРОШО

interface SearchFunction {
  (source: string, subString: string): boolean;
}

const fooSearch: SearchFunction = (source, subString) => { ... };

```

#### 4.5.4 Не используйте функциональные выражения

Всегда используйте стрелочные функции вместо функциональных выражений которые были до ES6 и задавались с помощью ключевого слова `function`.

```typescript
// ✅ ХОРОШО

bar(() => {
  this.doSomething();
});
```

```typescript
// ❌ ПЛОХО

bar(function() { ... })
```

**Исключение**: Функциональные выражения (определенные с помощью ключевого слова `function`) _возможно_ использовать только в том случае, если код должен динамически перепривязать `this`, хотя в коде в принципе _не рекомендуется_ перепривязывать `this`. В коде обычных функций (в отличие от стрелочных функций и методов) _не рекомендуется_ обращаться к `this`.

#### 4.5.5 Использование выражений или блоков в качестве тела функции

Используйте стрелочные функции с выражениями или блоками в качестве тела там, где это целесообразно.

{/* prettier-ignore */}
```typescript
// ✅ ХОРОШО

// Для объявления функции верхнего уровня используйте Function Declarations.
function someFunction() {
  // Вполне подходит использование блочных тел стрелочных функций, т.е. у которых тело функции представляет => { } :
  const receipts = books.map((b: Book) => {
    const receipt = payMoney(b.price);
    recordTransaction(receipt);
    return receipt;
  });

  // Использование выражения в качестве тела функции тоже подходит, если возвращаемое значение будет использоваться:
  const longThings = myValues.filter(v => v.length > 1000).map(v => String(v));

  function payMoney(amount: number) {
    // Function Declarations - это хорошо, но не обращайтесь к `this` в них. 
  }

  // Вложенные стрелочные функции могут быть назначены константе
  const computeTax = (amount: number) => amount * 0.12;
}
```

Используйте выражения в качестве тела функции только в том случае, если возвращаемое значение функции действительно используется.

{/* prettier-ignore */}
```typescript
// ❌ ПЛОХО

// ПЛОХО: используйте блочное тело функции ({ ... }) если возвращаемое значение функции не используется.
myPromise.then(v => console.log(v));
// ПЛОХО: этот тип проверяет, но возвращаемое значение все равно теряется.
let f: () => void;
f = () => 1;
```

{/* prettier-ignore */}
```typescript
// ✅ ХОРОШО

// ХОРОШО: возвращаемое значение не используется, поэтому применяется блочное тело функции.
myPromise.then(v => {
  console.log(v);
});
// ХОРОШО: в коде можно использовать блочное тело функции для повышения удобочитаемости.
const transformed = [1, 2, 3].map(v => {
  const intermediate = someComplicatedExpr(v);
  const more = acrossManyLines(intermediate);
  return worthWrapping(more);
});
// ХОРОШО: явный `void` гарантирует отсутствие утечки возвращаемого значения
myPromise.then(v => void console.log(v));
```

#### 4.5.6 Перепривязывание `this`

Функциональные выражения _не должны_ использовать `this`, если только они не существуют специально для перепривязки `this`. В большинстве случаев перепривязки `this` можно избежать, используя стрелочные функции или явно заданные параметры.

```typescript
// ❌ ПЛОХО

function clickHandler() {
  // Плохо: что такое «this» в этом контексте?
  this.textContent = 'Hello';
}
// Плохо: `this` неявно ссылается на document.body .
document.body.onclick = clickHandler;
```

```typescript
// ✅ ХОРОШО

// Хорошо: явная ссылка на объект из стрелочной функции.
document.body.onclick = () => {
  document.body.textContent = 'hello';
};
// Альтернатива: взять явно заданный параметр
const setTextFn = (e: HTMLElement) => {
  e.textContent = 'hello';
};
document.body.onclick = setTextFn.bind(null, document.body);
```

Предпочитайте стрелочные функции другим подходам к привязке `this`, таким как `f.bind(this)`, `goog.bind(f, this)` или `const self = this`.

#### 4.5.8 Стрелочные функции как свойства

В классах обычно _не рекомендуется_ содержать свойства, которые проинициализированы как стрелочные функции. Использование стрелочных функций как свойств требует чтобы вызывающая их функция корректно понимала, что у вызываемой функции уже есть привязанный `this`, что увеличивает путаницу в понимании того, что такое `this`, а сами места вызовов и ссылки использующие эти функции могут смотреться некорректно работающими (т.к. это требует дополнительных знаний об окружении за пределами локальной области вызывающей функции, чтобы определить, что они корректны). В коде _рекомендуется_ всегда использовать стрелочные функции для вызова методов экземпляра (`const handler = (x) => { this.listener(x); };`) и _не рекомендуется_ получать или передавать ссылки на методы экземпляра (~~`const handler = this.listener; handler(x);`~~).

<Callout
  type="info"
  emoji="ℹ️"
>
  Примечание: в некоторых специфических ситуациях, например, в случае привязки
  функций к шаблонам, стрелочные функции в качестве свойств полезны и создают
  гораздо более читабельный код. Руководствуйтесь здравым смыслом при
  использовании этого правила. Также см. раздел [Обработчики событий]() ниже.
</Callout>

```typescript
// ❌ ПЛОХО

class DelayHandler {
  constructor() {
    // Проблема: `this` не сохраняется в функции обратного вызова. `this` в обратном вызове
    // не будет экземпляром DelayHandler.
    setTimeout(this.patienceTracker, 5000);
  }
  private patienceTracker() {
    this.waitedPatiently = true;
  }
}
```

```typescript
// ❌ ПЛОХО

// Стрелочные функции обычно не рекомендуется задавать свойствам.
class DelayHandler {
  constructor() {
    // Плохо: этот код выглядит так, как будто тут забыли привязать `this`.
    setTimeout(this.patienceTracker, 5000);
  }
  private patienceTracker = () => {
    this.waitedPatiently = true;
  };
}
```

```typescript
// ✅ ХОРОШО

// Явное управление `this` во время вызова.
class DelayHandler {
  constructor() {
    // По возможности используйте анонимные функции.
    setTimeout(() => {
      this.patienceTracker();
    }, 5000);
  }
  private patienceTracker() {
    this.waitedPatiently = true;
  }
}
```

#### 4.5.9 Обработчики событий

Обработчики событий _могут_ использовать стрелочные функции, когда нет необходимости удалять обработчик (например, если событие генерируется самим классом). Если для обработчика впоследствии требуется удаление, тогда правильным подходом будет использование назначенной свойству стрелочной функции, поскольку они автоматически захватывают `this` и при этом обеспечивается постоянная ссылка на обработчик для его последующего удаления.

```typescript
// ✅ ХОРОШО

// Обработчики событий могут быть анонимными функциями или назначенные свойствам стрелочными функциями.
class Component {
  onAttached() {
    // Событие генерируется этим классом, удалять его не нужно.
    this.addEventListener('click', () => {
      this.listener();
    });
    // this.listener это постоянная ссылка на функцию-обработчик, которую мы позже можем удалить.
    window.addEventListener('onbeforeunload', this.listener);
  }
  onDetached() {
    // Событие генерируется окном (window). Если мы не удалим функцию-обработчик (this.listener), то она
    // сохранит ссылку на `this` к которой привязана, что приведет к утечке памяти.
    window.removeEventListener('onbeforeunload', this.listener);
  }
  // Стрелочная функция, хранящаяся в свойстве, автоматически привязывается к `this`.
  private listener = () => {
    confirm('Вы хотите покинуть страницу?');
  };
}
```

Не используйте `bind` в выражениях, которые устанавливают обработчики событий, потому что это создает временную ссылку, которую нельзя удалить.

```typescript
// ❌ ПЛОХО

// Привязка слушателей создает временную ссылку, которая недоступна для удаления.
class Component {
  onAttached() {
    // Это создает временную ссылку, которая нам не будет доступна для удаления.
    window.addEventListener('onbeforeunload', this.listener.bind(this));
  }
  onDetached() {
    // метод bind каждый раз создает новую ссылку, поэтому эта строка не делает ничего.
    window.removeEventListener('onbeforeunload', this.listener.bind(this));
  }
  private listener() {
    confirm('Вы хотите покинуть страницу?');
  }
}
```

### 4.8 Примитивные литералы

#### 4.8.3 Преобразование типов

В TypeScript коде _возможно_ использовать `String()` и `Boolean()` (примечание: без `new`!) функции, строковые шаблонные литералы или `!!` для преобразования типов.

```typescript
// ✅ ХОРОШО

const bool = Boolean(false);
const str = String(aNumber);
const bool2 = !!str;
const str2 = `result: ${bool2}`;
```

Значения перечислений `enum` (включая объединения перечислений и других типов) _не должны_ преобразовываться в логические значения с помощью `Boolean()` или `!!`, а должны вместо этого сравниваться явным образом с помощью операторов сравнения.

```typescript
// ❌ ПЛОХО

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
let enabled = Boolean(level);

const maybeLevel: SupportLevel|undefined = ...;
enabled = !!maybeLevel;
```

```typescript
// ✅ ХОРОШО

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
let enabled = level !== SupportLevel.NONE;

const maybeLevel: SupportLevel|undefined = ...;
enabled = level !== undefined && level !== SupportLevel.NONE;
```

<Callout
  type="info"
  emoji="ℹ️"
>
Почему?

Для большинства задач не имеет значения, числовое или строковое значение сопоставлено с именем перечисления во время выполнения программы, поскольку значения перечислений указываются в исходном коде по имени. Следовательно, инженеры привыкли не задумываться об этом, а потому нежелательны ситуации, когда это действительно важно, так как они будут приводить к неожиданностям. Так происходит и в случае преобразования перечислений в булевы значения; в частности, вероятно может быть неожиданным, что по умолчанию первое объявленное значение перечисления является ложным (потому что оно равно 0), в то время как остальные значения являются истинными. Пользователи, читающие код, в котором используется значение перечисления, могут даже не знать, является ли оно первым объявленным значением или нет.

</Callout>

Не приветствуется для приведения к строке использовать конкатенацию строк, так как при проверке кода мы отслеживаем, чтобы операнды оператора "плюс" имели совпадающие типы.

Код _должен_ использовать `Number()` для парсинга числовых значений и _должен_ явно проверять его возврат на значения `NaN`, за исключением случаев, когда из контекста точно известно, что сбой парсинга невозможен.

<Callout
  type="info"
  emoji="ℹ️"
>
  Примечание: `Number('')`, `Number(' ')`, и `Number('\t')` могут вернуть `0`
  вместо `NaN`. `Number('Infinity')` и `Number('-Infinity')` могут вернуть
  `Infinity` и `-Infinity` соответственно. Кроме того, экспоненциальная запись,
  такая как `Number('1e+309')` и `Number('-1e+309')`, может привести к
  переполнению и преобразованию в `Infinity`. Подобные случаи могут потребовать
  особого обращения.
</Callout>

```typescript
// ✅ ХОРОШО

const aNumber = Number('123');
if (!isFinite(aNumber)) throw new Error(...);
```

В коде _не должен_ использоваться унарный плюс (`+`) для преобразования строки в число. Парсинг чисел может привести к неудаче, иметь неожиданные исключительные ситуации и может быть признаком дурно пахнущего кода (парсинг чисел не на том уровне). Учитывая это, унарный плюс слишком легко пропустить при проверке кода.

```typescript
// ❌ ПЛОХО

const x = +y;
```

В коде также _не должны_ использоваться `parseInt` или `parseFloat` для парсинга чисел, за исключением случаев парсинга в строках недесятичных числовых значений (см. ниже). Обе эти функции игнорируют конечные символы в строке, что может привести к возникновению ошибочного состояния (например, парсинг `12 гномов` как `12`).

```typescript
// ❌ ПЛОХО

const n = parseInt(someString, 10); // Подвержено ошибкам,
const f = parseFloat(someString); // независимо от передачи основания системы счисления.
```

Код, требующий выполнить парсинг числа с указанием системы счисления, перед вызовом `parseInt` _должен_ проверить, что входные данные содержат только подходящие для этой системы счисления цифры;

```typescript
// ✅ ХОРОШО

if (!/^[a-fA-F0-9]+$/.test(someString)) throw new Error(...);
// Требуется для парсинга восьмеричного числа.
const n = parseInt(someString, 16);  // Допустимо только для основания числа != 10
```

Используйте `Number()`, а затем `Math.floor` или `Math.trunc` (там, где это возможно) для парсинга целых чисел:

```typescript
// ✅ ХОРОШО

let f = Number(someString);
if (isNaN(f)) handleError();
f = Math.floor(f);
```

**Неявное преобразование типов**

Не используйте явное логическое преобразование в условиях, в которых уже имеется неявное логическое преобразование. Это условия в операторах `if`, `for` и `while`.

```typescript
// ❌ ПЛОХО

const foo: MyInterface|null = ...;
if (!!foo) {...}
while (!!foo) {...}
```

```typescript
// ✅ ХОРОШО

const foo: MyInterface|null = ...;
if (foo) {...}
while (foo) {...}
```

[Как и в случае явных преобразований](), значения перечислений (включая объединения перечислений и других типов) _не должны_ неявно приводиться к логическим значениям, а должны сравниваться явным образом с помощью операторов сравнения.

```typescript
// ❌ ПЛОХО

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
if (level) {...}

const maybeLevel: SupportLevel|undefined = ...;
if (level) {...}
```

```typescript
// ✅ ХОРОШО

enum SupportLevel {
  NONE,
  BASIC,
  ADVANCED,
}

const level: SupportLevel = ...;
if (level !== SupportLevel.NONE) {...}

const maybeLevel: SupportLevel|undefined = ...;
if (level !== undefined && level !== SupportLevel.NONE) {...}
```

Другие типы значений могут быть либо неявно преобразованы в логические значения, либо явно сравнены с помощью операторов сравнения:

```typescript
// ✅ ХОРОШО

// Явное сравнение > 0 это хорошо:
if (arr.length > 0) {...}
// так же как и полагаться на неявное булево преобразование:
if (arr.length) {...}
```

### 4.9 Структуры управления

#### 4.9.1 Операторы и блоки потока управления

Операторы потока управления ( `if`, `else`, `for`, `do`, `while` и т. д.) всегда используют блоки в фигурных скобках для содержащего их кода, даже если тело содержит только один оператор. Первый оператор непустого блока должен начинаться с отдельной строки.

```typescript
// ✅ ХОРОШО

for (let i = 0; i < x; i++) {
  doSomethingWith(i);
}

if (x) {
  doSomethingWithALongMethodNameThatForcesANewLine(x);
}
```

```typescript
// ❌ ПЛОХО

if (x) doSomethingWithALongMethodNameThatForcesANewLine(x);

for (let i = 0; i < x; i++) doSomethingWith(i);
```

Исключением, при котором _возможно_ не использовать блоки, являются операторы `if`, которые умещаются на одной строке.

```typescript
// ✅ ХОРОШО

if (x) x.doFoo();
```

**Использование присваивания в операторах управления**

Предпочитайте избегать присваивания значений переменных внутри операторов управления. Присваивание легко спутать с проверкой на равенство внутри этих операторов.

{/* prettier-ignore */}
```typescript
// ❌ ПЛОХО

if (x = someFunction()) {
  // Присваивание легко перепутать с проверкой на равенство
  // ...
}
```

```typescript
// ✅ ХОРОШО

x = someFunction();
if (x) {
  // ...
}
```

В тех случаях, когда присваивание внутри оператора управления более предпочтительно, заключите это присваивание в дополнительные круглые скобки, чтобы указать, что оно сделано намеренно.

**Итерация контейнеров**

```typescript
// ✅ ХОРОШО

while ((x = someFunction())) {
  // Двойная скобка указывает на то, что присваивание сделано намеренно
  // ...
}
```

Для итерации по массивам предпочтительно использовать `for (... of someArr)`. Также приемлемо использовать `Array.prototype.forEach` или обычные циклы `for`:

```typescript
// ✅ ХОРОШО

for (const x of someArr) {
  // x - ссылается на значение из someArr
}

for (let i = 0; i < someArr.length; i++) {
  // Если необходим индекс, то используйте явный пересчет, а иначе используйте форму for/of.
  const x = someArr[i];
  // ...
}
for (const [i, x] of someArr.entries()) {
  // Альтернативная версия предыдущего.
}
```

Не используйте `for (... in ...)` для итерации по массивам. Это будет контринтуитивно давать индексы массива (в виде строк!), а не значения:

```typescript
// ❌ ПЛОХО

for (const x in someArray) {
  // x - это индекс!
}
```

`Object.prototype.hasOwnProperty` следует использовать в циклах `for`-`in`, чтобы исключить нежелательные свойства прототипа. Если это возможно, отдавайте предпочтение `for`-`of` с `Object.keys`, `Object.values` или `Object.entries` вместо `for`-`in`.

```typescript
// ✅ ХОРОШО

for (const key in obj) {
  if (!obj.hasOwnProperty(key)) continue;
  doWork(key, obj[key]);
}
for (const key of Object.keys(obj)) {
  doWork(key, obj[key]);
}
for (const value of Object.values(obj)) {
  doWorkValOnly(value);
}
for (const [key, value] of Object.entries(obj)) {
  doWork(key, value);
}
```

#### 4.9.3 Обработка исключений

Исключения — важная часть языка, и их следует использовать всякий раз, когда возникают исключительные случаи.

Пользовательские исключения предоставляют отличный способ передать дополнительную информацию об ошибках из функций. Их следует определить и использовать там, где встроенного типа `Error` недостаточно.

Предпочитайте создание исключений, а не специальные подходы к обработке ошибок (например, передачу ссылочного типа контейнера ошибок или возврат объекта со свойством ошибки).

**Использование `new` при создании экземпляров класса `Error`**

Всегда используйте `new Error()` при создании исключений вместо простого вызова `Error()`. В обоих случаях создается новый экземпляр `Error`, но использование `new` более согласуется с тем, как создаются экземпляры других объектов.

```typescript
// ✅ ХОРОШО

throw new Error('Foo is not a valid bar.');
```

```typescript
// ❌ ПЛОХО

throw Error('Foo is not a valid bar.');
```

**При выбрасывании исключений используйте только экземпляры класса `Error`**

JavaScript (и, следовательно, TypeScript) позволяет при выбрасывании исключений использовать произвольные значения. Однако если выброшенное значение не является экземпляром класса Error, то оно не получит записи трассировки стека, что затруднит отладку. Эта обработка распространяется на значения отклонения `Promise`, поскольку `Promise.reject(obj)` эквивалентен `throw obj;` в асинхронных функциях.

```typescript
// ❌ ПЛОХО

// плохо: не позволяет получить трассировку стека.
throw 'oh noes!';
// Для Promise
new Promise((resolve, reject) => void reject('oh noes!'));
Promise.reject();
Promise.reject('oh noes!');
```

Вместо этого, при выбрасывании исключений используйте только экземпляры класса (или подкласса) `Error`:

```typescript
// ✅ ХОРОШО

// При выбрасывании исключений используйте только экземпляры класса Error
throw new Error('oh noes!');
// ... или подтипы класса Error
class MyError extends Error {}
throw new MyError('my oh noes!');
// Для Promise
new Promise((resolve) => resolve()); // Нет отказа – это нормально.
new Promise((resolve, reject) => void reject(new Error('oh noes!')));
Promise.reject(new Error('oh noes!'));
```

**Перехват и проброс исключений**

В коде, при перехвате исключений, _рекомендуется_ рассматривать все бросаемые исключения как экземпляры класса `Error`.

```typescript
// ✅ ХОРОШО

function assertIsError(e: unknown): asserts e is Error {
  if (!(e instanceof Error)) throw new Error('e is not an Error');
}

try {
  doSomething();
} catch (e: unknown) {
  // Все выбрасываемые исключения должны быть подтипами класса Error. Не обрабатывайте другие
  // возможные значения, кроме случаев, когда вы точно знаете, что именно они будут выброшены.
  assertIsError(e);
  displayError(e.message);
  // или проброс
  throw e;
}
```

Обработчики исключений _не должны_ защитно обрабатывать типы, отличные от `Error`, за исключением случаев, когда достоверно известно, что вызываемый API выбрасывает исключения, не соответствующие типу `Error`, в нарушение вышеуказанного правила. В таком случае рекомендуется добавить комментарий, в котором специально указывается источник возникновения исключения, не соответствующего типу `Error`.

```typescript
// ✅ ХОРОШО

try {
  badApiThrowingStrings();
} catch (e: unknown) {
  // Примечание: это плохое API при выбрасывании исключения передает строку, вместо экземпляра класса Error
  if (typeof e === 'string') { ... }
}
```

<Callout
  type="info"
  emoji="ℹ️"
>
Почему?

Избегайте чрезмерно защитного программирования. Повторение одних и тех же защитных средств от проблемы, которой не будет существовать в большей части кода, приводит к появлению шаблонного кода, который не является полезным.

</Callout>

#### 4.9.4 Switch оператор

Каждый `switch` оператор _должен_ включать в себя блок по умолчанию (`default`), даже если там не содержится кода.

```typescript
// ✅ ХОРОШО

switch (x) {
  case Y:
    doSomethingElse();
    break;
  default:
  // ничего не делать.
}
```

Непустые группы операторов (`case ...`) _не должны_ проваливаться (обеспечивается опцией компилятора `noFallthroughCasesInSwitch`):

```typescript
// ❌ ПЛОХО

switch (x) {
  case X:
    doSomething();
  // дальнейший пропуск - не разрешен!
  case Y:
  // ...
}
```

Допускается пропуск пустых групп операторов:

```typescript
// ✅ ХОРОШО

switch (x) {
  case X:
  case Y:
    doSomething();
    break;
  default: // ничего не делать.
}
```

#### 4.9.5 Проверка равенства

Всегда используйте тройное равенство (`===`) и неравенство (`!==`). Операторы двойного равенства вызывают склонные к ошибкам приведения типов, которые трудны для понимания и работают медленнее в реализации виртуальных машин JavaScript. Смотрите также [JavaScript таблицу равенства](https://dorey.github.io/JavaScript-Equality-Table/).

```typescript
// ❌ ПЛОХО

if (foo == 'bar' || baz != bam) {
  // Трудное для понимания поведение из-за преобразования типов.
}
```

```typescript
// ✅ ХОРОШО

if (foo === 'bar' || baz !== bam) {
  // Здесь все хорошо и понятно.
}
```

**Исключение**: При сравнении с значением `null` _возможно_ использовать операторы `==` и `!=` для общего охвата `null` и `undefined` значений.

```typescript
// ✅ ХОРОШО

if (foo == null) {
  // Будет срабатывать, когда foo равен null или undefined.
}
```

#### 4.9.6 Утверждения типа (Type Assertions) и утверждения ненулевого значения (Non-nullability Assertions)

Утверждения типа (`x as SomeType`) и утверждения ненулевого значения (`y!`) не безопасны. Оба только заглушают компилятор TypeScript, но не вставляют никаких проверок во время выполнения, чтобы соответствовать этим утверждениям, поэтому они могут привести к сбою вашей программы во время выполнения.

По этой причине, вам _не рекомендуется_ использовать утверждения типа и утверждения ненулевого значения без явной или объяснимой причины.

Вместо этого:

```typescript
// ❌ ПЛОХО

(x as Foo).foo();

y!.bar();
```

Когда вы захотите произвести утверждение типа или утверждение ненулевого значения, то лучшим решением будет написать проверку, которая будет работать во время выполнения.

```typescript
// ✅ ХОРОШО

// предположим, что Foo - это класс.
if (x instanceof Foo) {
  x.foo();
}

if (y) {
  y.bar();
}
```

Иногда из-за некоторых внутренних особенностей вашего кода вы можете быть уверены, что форма утверждения безопасна. В таких ситуациях _рекомендуется_ добавить пояснение, объясняющее, почему вы согласны с небезопасным поведением:

```typescript
// ✅ ХОРОШО

// x это Foo, потому что ...
(x as Foo).foo();

// y не может быть null, потому что ...
y!.bar();
```

_Возможно_ обойтись без комментариев, если очевидны причины, лежащие в основе применения утверждения типа или утверждения ненулевого значения. Например, сгенерированный код-прототип всегда допускает значение `null`, но, возможно, в контексте кода хорошо известно, что определенные поля всегда предоставляются серверной частью. В таком случае, принимайте решение руководствуясь своим профессиональным видением.

**Синтаксис утверждения типа**

Утверждения типа _должны_ использовать синтаксис `as` (в отличие от синтаксиса угловых скобок). Это позволяет заключить утверждение в круглые скобки при обращении к элементу.

```typescript
// ❌ ПЛОХО

const x = (<Foo>z).length;
const y = <Foo>z.length;
```

```typescript
// ✅ ХОРОШО

// z должен быть Foo, потому что ...
const x = (z as Foo).length;
```

**Утверждение типа и объектные литералы**

Используйте аннотации типа (`: Foo`) вместо утверждения типа (`as Foo`) для указания типа объектного литерала. Это позволяет обнаружить ошибки рефакторинга, когда поля интерфейса меняются со временем.

```typescript
// ❌ ПЛОХО

interface Foo {
  bar: number;
  baz?: string; // был "bam", но позднее был переименован в "baz".
}

const foo = {
  bar: 123,
  bam: 'abc', // нет ошибки!
} as Foo;

function func() {
  return {
    bar: 123,
    bam: 'abc', // нет ошибки!
  } as Foo;
}
```

```typescript
// ✅ ХОРОШО

interface Foo {
  bar: number;
  baz?: string;
}

const foo: Foo = {
  bar: 123,
  bam: 'abc', // жалуется на то, что "bam" не был объявлен в Foo.
};

function func(): Foo {
  return {
    bar: 123,
    bam: 'abc', // жалуется на то, что "bam" не был объявлен в Foo.
  };
}
```

#### 4.9.7 Сохраняйте блоки try сфокусированными

Ограничьте количество кода внутри блока `try`, если это можно сделать без ущерба для читабельности.

```typescript
// ❌ ПЛОХО

try {
  const result = methodThatMayThrow();
  use(result);
} catch (error: unknown) {
  // ...
}
```

```typescript
// ✅ ХОРОШО

let result;
try {
  result = methodThatMayThrow();
} catch (error: unknown) {
  // ...
}
use(result);
```

Вынос не вызывающих исключений строк кода из блока try/catch помогает читающему код понять, какой метод выбрасывает исключения. Некоторые встраиваемые вызовы, которые не выбрасывают исключений, могут оставаться внутри блока, поскольку они могут не стоить дополнительных усложнений кода, связанных с добавлением временной переменной.

**Исключение**: Могут возникнуть проблемы с производительностью, если блоки `try` находятся внутри цикла. Расширение блоков `try` для охвата всего цикла — это нормально.

### 4.11 Запрещенные функции

#### 4.11.1 Примитивные типы & Классы-обертки

Код TypeScript _не должен_ создавать экземпляры классов-оберток для примитивных типов `String`, `Boolean` и `Number`. Классы-обертки имеют неожиданное поведение, такое как new `Boolean(false)` равное `true`.

```typescript
// ❌ ПЛОХО

const s = new String('hello');
const b = new Boolean(false);
const n = new Number(5);
```

```typescript
// ✅ ХОРОШО

const s = 'hello';
const b = false;
const n = 5;
```

Обертки можно вызывать как функции для приведения (что предпочтительнее использования `+` или объединения пустой строки) или создания символов. Дополнительную информацию см. в [разделе "Приведение типов"]().

#### 4.11.2 Автоматическая вставка точки с запятой

Не следует полагаться на автоматическую вставку точки с запятой (ASI). Явно завершайте все операторы с помощью точки с запятой. Это предотвращает ошибки, возникающие из-за неправильной вставки точки с запятой, а также обеспечивает совместимость с инструментами, которые имеют ограниченную поддержку ASI (например, clang-format).

## 5 Именование

### 5.1 Идентификаторы

Идентификаторы _должны_ использовать только ASCII символы, цифры, символы подчеркивания (для констант и названий методов структурных тестов) и знак `$`. Таким образом, каждое допустимое имя идентификатора соответствует регулярному выражению `[$\w]+`.

#### 5.1.1 Стиль именования

TypeScript отражает информацию в типах, поэтому имена _не рекомендуется_ дополнять информацией, которая включена в тип.

Несколько конкретных примеров для этого правила:

- Не используйте начальные или завершащие символы подчеркивания для приватных свойств или методов.
- Не используйте префикс `opt_` для необязательных параметров.
  - Для аксессоров, см. ниже [правила использования аксессоров]().
- Не стоит специально помечать интерфейсы (~~`IMyInterface`~~ или ~~`MyFooInterface`~~), если только они не идиоматичны в своей среде. Когда вы вводите интерфейс для класса, дайте ему имя, которое выражает причину существования интерфейса (например, `class TodoItem` и `interface TodoItemStorage` если интерфейс выражает формат, используемый для хранения/сериализации в JSON).
- Добавление к наблюдаемым элементам (`Observable`) суффикса `$` является распространенным внешним соглашением и может помочь устранить путаницу между наблюдаемыми и конкретными значениями. Решение о том, является ли это полезным соглашением, остается на усмотрение отдельных команд, но _рекомендуется_, чтобы оно было согласованным в рамках проектов.

#### 5.1.2 Описательные названия

Названия _должны_ быть описательными и ясными для новых читателей. Не используйте аббревиатуры, которые могут быть незнакомыми или двусмысленными для читателей за пределами вашего проекта и не сокращайте, удаляя в словах буквы.

- **Исключение**: Для переменных, область действия которых составляет не более 10 строк, включая аргументы, которые _не_ являются частью экспортируемого API, _возможно_ использование коротких (например, однобуквенных) имен переменных.

```typescript
// ✅ ХОРОШО

// Хорошие идентификаторы:
errorCount; // Без сокращений.
dnsConnectionIndex; // Большинство людей знают, что означает «DNS».
ReferrerUrl; // То же самое для «URL».
customerId; // «Id» встречается повсеместно и вряд ли будет понят неправильно.
```

```typescript
// ❌ ПЛОХО

// Запрещенные идентификаторы:
n; // Бессмысленно.
nErr; // Неоднозначное сокращение.
nCompConns; // Неоднозначное сокращение.
wgcConnections; // Только ваша группа знает, что это означает.
pcReader; // Многие вещи можно сократить до «ПК».
cstmrId; // Удаляет внутренние буквы.
kSecondsPerDay; // Не используйте венгерскую нотацию.
customerID; // Неправильный регистр "ID".
```

#### 5.1.3 Верблюжий регистр (Camel case)

Рассматривайте используемые в именах аббревиатуры типа акронимов как целые слова, т.е. используйте `loadHttpUrl`, а не ~~`loadHTTPURL`~~, если только это не обусловлено названием конкретной платформы (например `XMLHttpRequest`).

#### 5.1.4 Знак доллара

В идентификаторах, как правило, _не рекомендуется_ использовать символ `$`, за исключением случаев, когда это соответствуют соглашениям об именовании для сторонних фреймворков. Подробнее об использовании суффикса `$` для наблюдаемых (`Observable`) значений [см. ниже]().

### 5.2 Правила по типу идентификатора

| Стиль            | Категория                                                                                                                |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `UpperCamelCase` | класс / интерфейс / тип / перечисление / декоратор / параметры типа / функции компонента в параметре типа TSX/JSXElement |
| `lowerCamelCase` | переменная / параметр / функция / метод / свойство / псевдонимы модулей                                                  |
| `CONSTANT_CASE`  | глобальные константы, включая имена элементов перечислений (`enum`). См. ниже раздел [Константы](#константы)             |
| `#ident`         | подобные приватные идентификаторы не применяются                                                                         |

#### 5.2.1 Параметры типа

Для обозначения параметров типа, как например в `Array<T>`, _возможно_ использовать один символ верхнего регистра (`T`) или `UpperCamelCase`.

#### 5.2.2 Названия тестов

Название тестовых методов в Closure `testSuite` и подобных тестовых фреймворках в стиле xUnit _возможно_ представлять с разделителями `_`, например `testX_whenY_doesZ()`.

#### 5.2.3 `_` префикс/суффикс

Идентификаторы не должны использовать `_` в качестве префикса или суффикса.  
Это также означает что символ `_` сам по себе _не должен_ быть использован в качестве идентификатора (например, чтобы указать, что параметр не используется).

<Callout
  type="info"
  emoji="ℹ️"
>
  Cовет: Если вам нужны только некоторые элементы из массива (или TypeScript
  кортежа), вы можете вставить дополнительные запятые в выражение
  деструктуризации, чтобы игнорировать промежуточные элементы:
</Callout>

```typescript
// ✅ ХОРОШО

const [a, , b] = [1, 5, 10]; // a <- 1, b <- 10
```

#### 5.2.4 Импорты

Импорты пространств имен модулей пишутся в стиле `lowerCamelCase` в то время как файлы именуются в стиле `snake_case`, что означает, что корректные импорты не будут совпадать по стилю написания с именами файлов. Например:

```typescript
// ✅ ХОРОШО

import * as fooBar from './foo_bar';
```

Некоторые библиотеки могут широко использовать префиксы для импорта пространств имен, которые противоречат этой схеме именования, но их обширное использование в решениях с открытым исходным кодом делает этот нарушающий стиль более понятным. Единственными библиотеками, которые в настоящее время подпадают под это исключение, являются:

- **jquery**, использует `$` как префикс;
- **threejs**, использует `THREE` как префикс.

#### 5.2.5 Константы

**Иммутабельность**: Стиль `CONSTANT_CASE` указывает на то, что значение _предназначено_ быть неизменным и при этом такой стиль также _возможно_ использовать для значений, которые могут быть изменены технически (т.е. значений, которые не являются глубоко замороженными), чтобы явно указать пользователям на то, что эти значения нельзя изменять.

```typescript
// ✅ ХОРОШО

const UNIT_SUFFIXES = {
  milliseconds: 'ms',
  seconds: 's',
};
// Несмотря на то, что в соответствии с правилами JavaScript UNIT_SUFFIXES является изменяемым,
// верхний регистр символов обозначает для пользователей, что они не должны изменять значения.
```

Константой также может быть статическое свойство класса, которое предназначенно только для чтения (`static readonly`).

```typescript
// ✅ ХОРОШО

class Foo {
  private static readonly MY_SPECIAL_NUMBER = 5;

  bar() {
    return 2 * Foo.MY_SPECIAL_NUMBER;
  }
}
```

**Глобальность**: Только для элементов, объявленных на уровне модуля, статических полей классов уровня модуля и значений перечислений уровня модуля _возможно_ использовать `CONST_CASE` стиль. Если во время работы программы значение создается более одного раза (например, локальная переменная, объявленная в функции или статическое поле в классе, вложенном в функцию), тогда _должен_ использоваться `lowerCamelCase` стиль.

Если значение представляет собой стрелочную функцию которая реализует интерфейс, тогда это _возможно_ объявлять в `lowerCamelCase` стиле.

#### 5.2.6 Псевдонимы

При создании локального псевдонима существующего элемента, используйте формат уже существующего его обозначения. Локальный псевдоним _должен_ совпадать с существующим именем и форматом источника. Для переменных при создании локальных псевдонимов используйте `const`, а для полей класса - атрибут `readonly`.

<Callout
  type="info"
  emoji="ℹ️"
>
  Примечание: Если вы создаете псевдоним только ради использования его для
  шаблона в выбранном вами фреймворке, не забудьте также назначить
  соответствующие [модификаторы доступа]().
</Callout>

```typescript
// ✅ ХОРОШО

const { BrewStateEnum } = SomeType;
const CAPACITY = 5;

class Teapot {
  readonly BrewStateEnum = BrewStateEnum;
  readonly CAPACITY = CAPACITY;
}
```

## 7 Требования к набору инструментов

Стиль Google требует использования ряда инструментов определенным образом, описанных здесь.

### 7.1 Компилятор TypeScript

Все файлы TypeScript должны пройти проверку типа с использованием стандартной цепочки инструментов.

#### 7.1.1 @ts-ignore

Не используйте `@ts-ignore`, а также такие варианты, как `@ts-expect-error` или `@ts-nocheck`.

На первый взгляд кажется, что это простой способ исправить ошибку компилятора, но на практике конкретная ошибка компилятора часто вызывается более серьезной проблемой, которая может быть исправлена более явным путем.

Например, если вы используете `@ts-ignore` для подавления ошибок типизации, то будет трудно предсказать, какие типы в конечном итоге будет видеть окружающий код. Для многих ошибок типизации, полезны советы в разделе [как лучше всего использовать]() `any`.
