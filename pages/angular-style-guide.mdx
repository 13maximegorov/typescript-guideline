import { Callout, Tabs, FileTree } from 'nextra/components';

# Angular Style Guide

Оригинальное руководство по стилю от Angular: [https://angular.dev/style-guide](https://angular.dev/style-guide).

## Введение

В этом руководстве по стилю представлены предпочтительные соглашения и, что немаловажно, объясняется, почему.

## Словарь стиля

Каждое руководство описывает либо хорошую, либо плохую практику, и все они имеют единообразную форму.

Формулировка каждого руководства указывает на то, насколько сильна рекомендация.

**Do** – это то, чему всегда нужно следовать. «Всегда», возможно, слишком сильное слово. Рекомендации, которым следует следовать буквально всегда, встречаются крайне редко. С другой стороны, вам нужен действительно необычный случай, чтобы нарушить принцип **Do**.

Учтите, что руководящие принципы, как правило, следует соблюдать. Если вы полностью понимаете смысл рекомендаций и у вас есть веская причина отклониться, сделайте это. Стремитесь быть последовательными.

Избегать указывает на то, что вам почти никогда не следует делать. Примеры кода, которые следует избегать, имеют безошибочно узнаваемый красный заголовок.

<Callout type="info" emoji="ℹ️">
Подобный блок обосновывает необходимость выполнения указанных перед
ним рекомендаций.

</Callout>

## Соглашение о структуре файлов

В некоторых примерах кода отображается файл, который имеет один или несколько сопутствующих файлов с одинаковыми именами. Например, `hero.component.ts` и `hero.component.html`.

В рекомендациях используется ярлык `hero.component.ts|html|css|spec` для представления этих различных файлов. Использование этого ярлыка делает файловую структуру данного руководства более удобной для чтения и более краткой.

## Единая ответственность

Примените принцип единой ответственности [(SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle) ко всем компонентам, службам и другим символам. Это помогает сделать приложение более чистым, простым для чтения и обслуживания, а также более пригодным для тестирования.

## Правило одного

#### Стиль 01-01

Определите что-то одно, например службу или компонент, для каждого файла.

Рассмотрите возможность ограничения файлов до 400 строк кода.

<Callout type="info" emoji="ℹ️">
Один компонент на файл значительно упрощает чтение, поддержку и позволяет
избежать конфликтов с командами системы контроля версий.

Наличие одного компонента в файле позволяет избежать скрытых ошибок, которые
часто возникают при объединении компонентов в файле, когда они могут
использовать общие переменные, создавать нежелательные замыкания или
нежелательную связь с зависимостями.

Один компонент может быть экспортируемым по умолчанию для своего файла, что
облегчает отложенную загрузку с помощью маршрутизатора.

</Callout>

Главное — сделать код более пригодным для повторного использования, более читаемым и менее подверженным ошибкам.

В следующем отрицательном примере определяется `AppComponent`, загружается приложение, определяется объект модели `Hero` и загружаются герои с сервера в одном файле. **Не делай этого**.

{/* prettier-ignore */}
```ts filename="app/heroes/hero.component.ts"
// ❌ ПЛОХО

import { Component, NgModule, OnInit } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

interface Hero {
  id: number;
  name: string;
}

@Component({
  selector: 'app-root',
  template: `
    <h1>{{ title }}</h1>
    <pre>{{ heroes | json }}</pre>
  `,
  styleUrls: ['../app.component.css'],
})

export class AppComponent implements OnInit {
  title = 'Tour of Heroes';
  heroes: Hero[] = [];
  ngOnInit() {
    getHeroes().then((heroes) => (this.heroes = heroes));
  }
}

@NgModule({
  imports: [BrowserModule],
  declarations: [AppComponent],
  exports: [AppComponent],
  bootstrap: [AppComponent],
})

export class AppModule {}

platformBrowserDynamic().bootstrapModule(AppModule);

const HEROES: Hero[] = [
  { id: 1, name: 'Bombasto' },
  { id: 2, name: 'Tornado' },
  { id: 3, name: 'Magneta' },
];

function getHeroes(): Promise<Hero[]> {
  return Promise.resolve(HEROES); // TODO: get hero data from the server;
}
```

Лучше всего перераспределить компонент и поддерживающие его классы в отдельные файлы.

{/* prettier-ignore */}
<Tabs items={['src/01-01/main.ts', 'src/01-01/app/app.module.ts', 'src/01-01/app/app.component.ts', 'src/01-01/app/heroes/heroes.component.ts', 'src/01-01/app/heroes/shared/hero.service.ts', 'src/01-01/app/heroes/shared/hero.model.ts', 'src/01-01/app/heroes/shared/mock-heroes.ts']}>
  <Tabs.Tab>
    ```ts 
      // ✅ ХОРОШО

      import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';
      import {AppModule} from './app/app.module';

      platformBrowserDynamic().bootstrapModule(AppModule);
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```ts
      // ✅ ХОРОШО

      import {NgModule} from '@angular/core';
      import {BrowserModule} from '@angular/platform-browser';
      import {RouterModule} from '@angular/router';
      import {AppComponent} from './app.component';
      import {HeroesComponent} from './heroes/heroes.component';

      @NgModule({
        imports: [
          BrowserModule,
          RouterModule.forChild([{path: '01-01', component: AppComponent}]),
        ],
        declarations: [AppComponent, HeroesComponent],
        exports: [AppComponent],
        bootstrap: [AppComponent],
      })
      export class AppModule {}
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```ts
      // ✅ ХОРОШО

      import {Component} from '@angular/core';
      import {HeroService} from './heroes';

      @Component({
        selector: 'toh-app',
        template: `
            <toh-heroes></toh-heroes>
          `,
        styleUrls: ['./app.component.css'],
        providers: [HeroService],
      })
      export class AppComponent {}
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```ts
      // ✅ ХОРОШО

      import {Component, OnInit} from '@angular/core';
      import {Hero, HeroService} from './shared';

      @Component({
        selector: 'toh-heroes',
        template: `
            <pre>{{heroes | json}}</pre>
          `,
      })
      export class HeroesComponent implements OnInit {
        heroes: Hero[] = [];
        constructor(private heroService: HeroService) {}
        ngOnInit() {
          this.heroService.getHeroes().then((heroes) => (this.heroes = heroes));
        }
      }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```ts
      // ✅ ХОРОШО

      import {Injectable} from '@angular/core';
      import {HEROES} from './mock-heroes';

      @Injectable()
      export class HeroService {
        getHeroes() {
          return Promise.resolve(HEROES);
        }
      }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```ts
      // ✅ ХОРОШО

      export interface Hero {
        id: number;
        name: string;
      }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```ts
      // ✅ ХОРОШО

      import {Hero} from './hero.model';

      export const HEROES: Hero[] = [
        {id: 1, name: 'Bombasto'},
        {id: 2, name: 'Tornado'},
        {id: 3, name: 'Magneta'},
      ];
    ```

  </Tabs.Tab>
</Tabs>

По мере роста приложения это правило становится еще более важным.

## Наименование

Соглашения об именах чрезвычайно важны для удобства сопровождения и читаемости. В этом руководстве рекомендуются соглашения об именовании имени файла и имени символа.

### Общие правила именования

#### Стиль 02-01

**Следуйте** шаблону, который описывает функцию символа, а затем его тип. Рекомендуемый шаблон — `feature.type.ts`.

<Callout type="info" emoji="ℹ️">
Соглашения об именах помогают обеспечить единообразный способ быстрого поиска контента. Последовательность в рамках проекта имеет жизненно важное значение. Важна стабильность в команде. Последовательность во всей компании обеспечивает огромную эффективность.

Соглашения об именах должны помочь быстрее найти нужный код и облегчить его понимание.

Названия папок и файлов должны четко передавать их предназначение. Например, `app/heroes/hero-list.component.ts` может содержать компонент, который управляет списком героев.

</Callout>

### Разделяйте имена файлов точками и тире.

#### Стиль 02-02

**Используйте** тире для разделения слов в описательном названии.

**Используйте** точки, чтобы отделить описательное имя от типа.

**Используйте** согласованные имена типов для всех компонентов, следуя шаблону, который описывает функцию компонента, а затем его тип. Рекомендуемый шаблон — `feature.type.ts`.

**Используйте** обычные имена типов, включая `.service`, `.component`, `.pipe`, `.module` и `.directive`. При необходимости придумайте дополнительные имена типов, но старайтесь не создавать слишком много.

<Callout type="info" emoji="ℹ️">
Имена типов обеспечивают единообразный способ быстро определить, что находится в файле.

Имена типов позволяют легко найти определенный тип файла с помощью редактора или методов нечеткого поиска в IDE.

Несокращенные имена типов, такие как `.service`, являются описательными и однозначными. Такие сокращения, как `.srv`, `.svc` и `.serv`, могут сбить с толку.

Имена типов обеспечивают сопоставление с образцом для любых автоматизированных задач.

</Callout>

### Символы и имена файлов

#### Стиль 02-03

**Используйте** согласованные имена для всех активов, названных в честь того, что они представляют.

**Используйте** верхний регистр для имен классов.

**Сопоставьте** имя символа с именем файла.

**Добавляйте** к имени символа обычный суффикс (например, `Component`, `Directive`, `Module`, `Pipe` или `Service`) для объекта этого типа.

**Присвойте** имени файла обычный суффикс (например, `.component.ts`, `.directive.ts`, `.module.ts`, `.pipe.ts` или `.service.ts`) для файла этого типа.

<Callout type="info" emoji="ℹ️">
Согласованные соглашения позволяют легко быстро идентифицировать и ссылаться на активы разных типов.

</Callout>

| Символьное наименование                                                              | Имя файла                |
| ------------------------------------------------------------------------------------ | ------------------------ |
| `@Component({ }) export class AppComponent { }`                                      | app.component.ts         |
| `@Component({ }) export class HeroesComponent { }`                                   | heroes.component.ts      |
| `@Component({ }) export class HeroListComponent { }`                                 | hero-list.component.ts   |
| `@Component({ }) export class HeroDetailComponent { }`                               | hero-detail.component.ts |
| `@Directive({ }) export class ValidationDirective { }`                               | validation.directive.ts  |
| `@NgModule({ }) export class AppModule`                                              | app.module.ts            |
| `@Pipe({ name: 'initCaps' }) export class InitCapsPipe implements PipeTransform { }` | init-caps.pipe.ts        |
| `@Injectable() export class UserProfileService { } `                                 | user-profile.service.ts  |

### Названия служб

#### Стиль 02-04

Используйте согласованные имена для всех служб, названных в честь их функций.

Добавьте к имени класса обслуживания суффикс `Service`. Например, то, что получает данные или героев, следует называть `DataService` или `HeroService`.

Некоторые термины однозначно являются услугами. Обычно они указывают на агентство, оканчиваясь на «-er». Вы можете предпочесть назвать службу, регистрирующую сообщения, `Logger`, а не `LoggerService`. Решите, приемлемо ли это исключение для вашего проекта. Как всегда, стремитесь к последовательности.

<Callout type="info" emoji="ℹ️">
Обеспечивает единый способ быстрой идентификации и ссылки на службы.

Четкие имена служб, такие как `Logger`, не требуют суффикса.

Имена служб, такие как `Credit`, являются существительными и требуют суффикса, и их следует называть с суффиксом, когда неясно, является ли это службой или чем-то еще.

</Callout>

| Символьное наименование                          | Имя файла            |
| ------------------------------------------------ | -------------------- |
| `@Injectable() export class HeroDataService { }` | hero-data.service.ts |
| `@Injectable() export class CreditService { }`   | credit.service.ts    |
| `@Injectable() export class Logger { }`          | logger.service.ts    |

### Начальная загрузка

#### Стиль 02-05

Поместите загрузочную информацию и логику платформы для приложения в файл с именем `main.ts`.

Включите обработку ошибок в логику начальной загрузки.

Избегайте помещения логики приложения в `main.ts`. Вместо этого рассмотрите возможность размещения его в компоненте или сервисе.

<Callout type="info" emoji="ℹ️">
Соблюдает единое соглашение для логики запуска приложения.

Следует знакомому соглашению других технологических платформ.

</Callout>

{/* prettier-ignore */}
```ts filename="main.ts"
  // ✅ ХОРОШО

  import {AppComponent} from './app/app.component';
  import {bootstrapApplication} from '@angular/platform-browser';

  bootstrapApplication(AppComponent);
```

#### Стиль 05-02

Используйте dashed-case или kebab-case для именования селекторов элементов компонентов.

{/* prettier-ignore */}
```ts filename="hero-button.component.ts"
  // ❌ ПЛОХО
  
  @Component({
    standalone: true,
    selector: 'tohHeroButton',
    templateUrl: './hero-button.component.html',
  })
  export class HeroButtonComponent {}
```

{/* prettier-ignore */}
<Tabs items={['hero-button.component.ts', 'hero-button.component.html']}>
  <Tabs.Tab>
    ```ts
      // ✅ ХОРОШО

      @Component({
        standalone: true,
        selector: 'toh-hero-button',
        templateUrl: './hero-button.component.html',
      })
      export class HeroButtonComponent {}
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```html
      // ✅ ХОРОШО

      <toh-hero-button></toh-hero-button>
    ```

  </Tabs.Tab>
</Tabs>

### Пользовательский префикс компонента

#### Стиль 02-07

**Используйте** значение селектора элемента, написанное через дефис и строчными буквами; например, `admin-users`.

**Используйте** префикс, который идентифицирует область функций или само приложение.

<Callout type="info" emoji="ℹ️">
Предотвращает конфликты имен элементов с компонентами в других приложениях и с собственными элементами HTML.

Упрощает продвижение и распространение компонента в других приложениях.

Компоненты легко идентифицировать в DOM.

</Callout>

{/* prettier-ignore */}
```ts filename="hero.component.ts"
// ❌ ПЛОХО

@Component({
  standalone: true,
  selector: 'hero',
  template: '',
})
export class HeroComponent {}
```

{/* prettier-ignore */}
```ts filename="hero.component.ts"
// ✅ ХОРОШО

@Component({
...
  standalone: true,
  selector: 'toh-hero',
})
export class HeroComponent {}
```

{/* prettier-ignore */}
```ts filename="users.component.ts"

// ❌ ПЛОХО

@Component({
  standalone: true,
  selector: 'users',
  template: '',
})
export class UsersComponent {}
```

{/* prettier-ignore */}
```ts filename="users.component.ts"
// ✅ ХОРОШО

@Component({
...
  standalone: true,
  selector: 'admin-users',
})
export class UsersComponent {}
```

### Селекторы директив

#### Стиль 02-06

**Используйте** нижний регистр для именования селекторов директив.

<Callout type="info" emoji="ℹ️">
Сохраняет имена свойств, определенных в директивах, привязанных к представлению, в соответствии с именами атрибутов.

Анализатор HTML Angular чувствителен к регистру и распознает нижний верблюжий регистр.

</Callout>

### Пользовательский префикс директивы

#### Стиль 02-08

**Пишите** селекторы, не являющиеся элементами, в нижнем регистре, если только селектор не предназначен для соответствия собственному атрибуту HTML.

**Не добавляйте** к имени директивы префикс `ng`, поскольку этот префикс зарезервирован для Angular, и его использование может вызвать ошибки, которые трудно диагностировать.

{/* prettier-ignore */}
```ts filename="validate.directive.ts"
// ❌ ПЛОХО

@Directive({
  standalone: true,
  selector: '[validate]',
})
export class ValidateDirective {}
```

{/* prettier-ignore */}
```ts filename="validate.directive.ts"
// ✅ ХОРОШО

@Directive({
  standalone: true,
  selector: '[tohValidate]',
})
export class ValidateDirective {}
```

### Названия пайпов

#### 02-09

Используйте согласованные имена для всех каналов, названные в честь их функции. Имя класса канала должно использовать `UpperCamelCase` (общее соглашение для имен классов), а соответствующая строка имени должна использовать LowerCamelCase. В строке `name` нельзя использовать дефисы («дефис» или «кебаб-регистр»).

<Callout type="info" emoji="ℹ️">
Обеспечивает единый способ быстрой идентификации и ссылки на трубы.

</Callout>

| Символьное наименование                                                                                | Имя файла         |
| ------------------------------------------------------------------------------------------------------ | ----------------- |
| `@Pipe({ standalone: true, name: 'ellipsis' }) export class EllipsisPipe implements PipeTransform { }` | ellipsis.pipe.ts  |
| `@Pipe({ standalone: true, name: 'initCaps' }) export class InitCapsPipe implements PipeTransform { }` | init-caps.pipe.ts |

### Имена файлов модульных тестов

#### Стиль 02-10

**Называйте** файлы спецификаций тестов так же, как и тестируемый ими компонент.

**Называйте** файлы спецификаций тестов с суффиксом `.spec`.

<Callout type="info" emoji="ℹ️">
Обеспечивает последовательный способ быстрой идентификации тестов.

Обеспечивает сопоставление шаблонов для karma или других средств запуска тестов.

</Callout>

| Тип теста  | Имя файла                                                                             |
| ---------- | ------------------------------------------------------------------------------------- |
| Components | heroes.component.spec.ts, hero-list.component.spec.ts , hero-detail.component.spec.ts |
| Services   | logger.service.spec.ts, hero.service.spec.ts, filter-text.service.spec.ts             |
| Pipes      | ellipsis.pipe.spec.ts, init-caps.pipe.spec.ts                                         |

## Структура приложения и NgModules

Имейте краткосрочное представление о реализации и долгосрочное видение. Начните с малого, но помните, куда движется приложение.

Весь код приложения находится в папке с именем `src`. Все функциональные области находятся в отдельной папке.

Весь контент представляет собой один актив на файл. Каждый компонент, служба и канал находятся в отдельном файле. Все сценарии сторонних поставщиков хранятся в другой папке, а не в папке `src`. Используйте соглашения об именах файлов, указанные в этом руководстве.

### Общие структурные рекомендации

#### Стиль 04-06

Начинайте с малого, но имейте в виду, в каком направлении движется приложение.

Имейте краткосрочное представление о реализации и долгосрочное видение.

Поместите весь код приложения в папку с именем `src`.

Рассмотрите возможность создания папки для компонента, если он имеет несколько сопутствующих файлов (`.ts`, `.html`, `.css` и `.spec`).

<Callout type="info" emoji="ℹ️">
Помогает сохранить структуру приложения небольшой и простой в обслуживании на ранних стадиях, а также легко развивать ее по мере роста приложения.

Компоненты часто имеют четыре файла (например, _.html, _.css, _.ts и _.spec.ts) и могут быстро засорять папку.

</Callout>

Вот совместимая структура папок и файлов:

project root

<FileTree>
  <FileTree.Folder
    name="src"
    defaultOpen
  >
    <FileTree.Folder name="app">
      <FileTree.Folder name="core">
        <FileTree.File name="exception.service.ts|spec.ts" />
        <FileTree.File name="user-profile.service.ts|spec.ts" />
      </FileTree.Folder>
      <FileTree.Folder name="heroes">
        <FileTree.Folder name="hero">
          <FileTree.File name="hero.component.ts|html|css|spec.ts" />
        </FileTree.Folder>
        <FileTree.Folder name="hero-list">
          <FileTree.File name="hero-list.component.ts|html|css|spec.ts" />
        </FileTree.Folder>
        <FileTree.Folder name="shared">
          <FileTree.File name="hero-button.component.ts|html|css|spec.ts" />
          <FileTree.File name="hero.model.ts" />
          <FileTree.File name="hero.service.ts|spec.ts" />
        </FileTree.Folder>
        <FileTree.File name="heroes.component.ts|html|css|spec.ts" />
        <FileTree.File name="heroes.routes.ts" />
      </FileTree.Folder>
      <FileTree.Folder name="shared">
        <FileTree.File name="init-caps.pipe.ts|spec.ts" />
        <FileTree.File name="filter-text.component.ts|spec.ts" />
        <FileTree.File name="filter-text.service.ts|spec.ts" />
      </FileTree.Folder>
      <FileTree.Folder name="villains">
        <FileTree.Folder name="villain">
          <FileTree.File name="..." />
        </FileTree.Folder>
        <FileTree.Folder name="villain-list">
          <FileTree.File name="..." />
        </FileTree.Folder>
        <FileTree.Folder name="shared">
          <FileTree.File name="..." />
        </FileTree.Folder>
        <FileTree.File name="villains.component.ts|html|css|spec.ts" />
        <FileTree.File name="villains.module.ts" />
        <FileTree.File name="villains-routing.module.ts" />
      </FileTree.Folder>
      <FileTree.File name="app.component.ts|html|css|spec.ts" />
      <FileTree.File name="app.routes.ts" />
    </FileTree.Folder>
    <FileTree.File name="main.ts" />
    <FileTree.File name="index.html" />

  </FileTree.Folder>
  <FileTree.Folder
    name="node_modules"
    defaultOpen
  ></FileTree.Folder>
  <FileTree.Folder
    name="..."
    defaultOpen
  ></FileTree.Folder>
</FileTree>

<Callout
  type="info"
  emoji="ℹ️"
>
  ПОЛЕЗНО: хотя компоненты в выделенных папках широко предпочтительнее, другой
  вариант для небольших приложений — хранить компоненты в плоском виде (не в
  выделенной папке). При этом в существующую папку добавляется до четырех
  файлов, но при этом уменьшается вложенность папок. Что бы вы ни выбрали,
  будьте последовательны.
</Callout>

### Структура папок по функциям

#### Style 04-07

Создавайте папки, названные в соответствии с функциональной областью, которую они представляют.

<Callout type="info" emoji="ℹ️">
Разработчик может найти код и с первого взгляда определить, что представляет собой каждый файл. Структура максимально плоская, в ней нет повторяющихся или избыточных названий.

Помогает уменьшить загромождение приложения за счет организации контента.

Когда файлов много, например более 10, найти их проще при наличии единообразной структуры папок и сложнее при плоской структуре.

</Callout>

### Корневой модуль приложения (App root module)

<Callout
  type="error"
  emoji="️❗"
>
  ВАЖНО: Следующие рекомендации руководства по стилю предназначены для
  приложений, основанных на NgModule. Вместо этого новые приложения должны
  использовать автономные компоненты, директивы и каналы.
</Callout>

#### Стиль 04-08

Создайте NgModule в корневой папке приложения, например, в `/src/app`, если вы создаете приложение на основе `NgModule`.

<Callout type="info" emoji="ℹ️">
Для каждого приложения на основе `NgModule` требуется как минимум один корневой `NgModule`.

Рассмотрите возможность назвать корневой модуль `app.module.ts` - это Облегчает поиск и идентификацию корневого модуля.

</Callout>

{/* prettier-ignore */}
```ts filename="app/app.module.ts"
import {NgModule} from '@angular/core';
import {BrowserModule} from '@angular/platform-browser';
...
import {AppComponent} from './app.component';
import {HeroesComponent} from './heroes/heroes.component';

@NgModule({
  imports: [
    BrowserModule,
...
  ],
  declarations: [AppComponent, HeroesComponent],
  exports: [AppComponent],
})
export class AppModule {}
```

### Функциональные модули

#### Стиль 04-09

Создайте `NgModule` для всех отдельных функций приложения; например, функция `Heroes`.

Поместите функциональный модуль в папку с тем же именем, что и функциональная область; например, в `app/heroes`.

Назовите файл функционального модуля, отражая имя функциональной области и папки; например, `app/heroes/heroes.module.ts`.

Назовите символ функционального модуля, отражающий имя функциональной области, папки и файла; например, `app/heroes/heroes.module.ts` определяет `HeroesModul`e`.

<Callout type="info" emoji="ℹ️">
Функциональный модуль может раскрывать или скрывать свою реализацию от других модулей.

Функциональный модуль идентифицирует отдельные наборы связанных компонентов, которые составляют функциональную область.

Функциональный модуль можно легко перенаправить как с нетерпением, так и лениво.

Функциональный модуль определяет четкие границы между конкретными функциями и другими функциями приложения.

Функциональный модуль помогает прояснить и упростить распределение обязанностей по разработке между различными командами.

Функциональный модуль можно легко изолировать для тестирования.

</Callout>

### Модуль общих функций

#### Стиль 04-10

Создайте функциональный модуль с именем `SharedModule` в общей папке; например, `app/shared/shared.module.ts` определяет `SharedModule`.

Обязательно объявляйте компоненты, директивы и каналы в общем модуле, если эти элементы будут повторно использоваться и на них будут ссылаться компоненты, объявленные в других функциональных модулях.

Рассмотрите возможность использования имени SharedModule, когда на содержимое общего модуля ссылаются во всем приложении.

Рассмотрите возможность не предоставлять услуги в общих модулях. Службы обычно представляют собой отдельные элементы, которые предоставляются один раз для всего приложения или в определенном функциональном модуле. Однако есть исключения. Например, в следующем примере кода обратите внимание, что `SharedModule` предоставляет `FilterTextService`. Здесь это приемлемо, поскольку служба не имеет состояния, т. е. новые экземпляры не влияют на потребителей службы.

Импортируйте все модули, необходимые для ресурсов в `SharedModule`; например, `CommonModule` и `FormsModule`.

<Callout type="info" emoji="ℹ️">
`SharedModule` будет содержать компоненты, директивы и каналы, которым могут потребоваться функции другого общего модуля; например, `ngFor` в `CommonModule`.

Объявите все компоненты, директивы и каналы в `SharedModule`.

Экспортируйте из `SharedModule` все символы, которые должны использовать другие функциональные модули.

`SharedModule` существует для того, чтобы сделать часто используемые компоненты, директивы и каналы доступными для использования в шаблонах компонентов во многих других модулях.

Избегайте указания одноэлементных поставщиков всего приложения в `SharedModule`. Преднамеренные синглтоны — это нормально.

Отложенно загружаемый функциональный модуль, который импортирует этот общий модуль, создаст собственную копию службы и, вероятно, приведет к нежелательным результатам.

Вы не хотите, чтобы каждый модуль имел свой отдельный экземпляр одноэлементных сервисов. Однако существует реальная опасность того, что это произойдет, если `SharedModule` предоставит услугу.

</Callout>

project root

<FileTree>
  <FileTree.Folder
    name="src"
    defaultOpen
  >
    <FileTree.Folder name="app">
      <FileTree.Folder name="shared">
        <FileTree.File name="shared.module.ts" />
        <FileTree.File name="init-caps.pipe.ts|spec.ts" />
        <FileTree.File name="filter-text.component.ts|spec.ts" />
        <FileTree.File name="filter-text.service.ts|spec.ts" />
      </FileTree.Folder>
      <FileTree.File name="app.component.ts|html|css|spec.ts" />
      <FileTree.File name="app.module.ts" />
      <FileTree.File name="app.routes.ts" />
    </FileTree.Folder>
    <FileTree.File name="main.ts" />
    <FileTree.File name="index.html" />

  </FileTree.Folder>
</FileTree>

{/* prettier-ignore */}
<Tabs items={['app/shared/shared.module.ts', 'app/shared/init-caps.pipe.ts', 'app/shared/filter-text/filter-text.component.ts', 'app/shared/filter-text/filter-text.service.ts', 'app/heroes/heroes.component.ts', 'app/heroes/heroes.component.html']}>
  <Tabs.Tab>
    ```ts 
      import {NgModule} from '@angular/core';
      import {CommonModule} from '@angular/common';
      import {FormsModule} from '@angular/forms';

      import {FilterTextComponent} from './filter-text/filter-text.component';
      import {FilterTextService} from './filter-text/filter-text.service';
      import {InitCapsPipe} from './init-caps.pipe';

      @NgModule({
        imports: [CommonModule, FormsModule],
        declarations: [FilterTextComponent, InitCapsPipe],
        providers: [FilterTextService],
        exports: [CommonModule, FormsModule, FilterTextComponent, InitCapsPipe],
      })
      export class SharedModule {}
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```ts
      import {Pipe, PipeTransform} from '@angular/core';
      
      @Pipe({name: 'initCaps'})
      export class InitCapsPipe implements PipeTransform {
        transform = (value: string) => value;
      }
    ```
  </Tabs.Tab>
  <Tabs.Tab>
    ```ts
      import {Component, EventEmitter, Output} from '@angular/core';

      @Component({
        selector: 'toh-filter-text',
        template:
          '<input type="text" id="filterText" [(ngModel)]="filter" (keyup)="filterChanged($event)" />',
      })

      export class FilterTextComponent {
        @Output() changed: EventEmitter<string>;
        filter = '';

        constructor() {
          this.changed = new EventEmitter<string>();
        }

        clear() {
          this.filter = '';
        }

        filterChanged(event: any) {
          event.preventDefault();
          console.log(`Filter Changed: ${this.filter}`);
          this.changed.emit(this.filter);
        }
      }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```ts
      import {Injectable} from '@angular/core';

      @Injectable()
      export class FilterTextService {
        constructor() {
          console.log('Created an instance of FilterTextService');
        }

        filter(data: string, props: Array<string>, originalList: Array<any>) {
          let filteredList: any[];
          if (data && props && originalList) {
            data = data.toLowerCase();
            const filtered = originalList.filter((item) => {
              let match = false;
              for (const prop of props) {
                if (item[prop].toString().toLowerCase().indexOf(data) > -1) {
                  match = true;
                  break;
                }
              }
              return match;
            });
            filteredList = filtered;
          } else {
            filteredList = originalList;
          }
          return filteredList;
        }
      }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```ts
      import {Component} from '@angular/core';
      import {FilterTextService} from '../shared/filter-text/filter-text.service';

      @Component({
        selector: 'toh-heroes',
        templateUrl: './heroes.component.html',
      })

      export class HeroesComponent {
        heroes = [
          {id: 1, name: 'Windstorm'},
          {id: 2, name: 'Bombasto'},
          {id: 3, name: 'Magneta'},
          {id: 4, name: 'Tornado'},
        ];

        filteredHeroes = this.heroes;

        constructor(private filterService: FilterTextService) {}

        filterChanged(searchText: string) {
          this.filteredHeroes = this.filterService.filter(searchText, ['id', 'name'], this.heroes);
        }
      }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```html
      <div>This is heroes component</div>
      <ul>
        <li *ngFor="let hero of filteredHeroes">
          {{ hero.name }}
        </li>
      </ul>
      <toh-filter-text (changed)="filterChanged($event)"></toh-filter-text>
    ```
  </Tabs.Tab>
</Tabs>

### Папки с отложенной загрузкой

#### Стиль 04-11

Отдельная функция приложения или рабочий процесс могут загружаться отложенно или по требованию, а не при запуске приложения.

Поместите содержимое отложенно загруженных функций в папку отложенной загрузки. Типичная папка с отложенной загрузкой содержит компонент маршрутизации, его дочерние компоненты и связанные с ними ресурсы.

Папка позволяет легко идентифицировать и изолировать содержимое объекта.

## Компоненты

#### Стиль 05-03

Рассмотрите возможность предоставления компонентам селектора элементов, а не селекторов атрибутов или классов.

<Callout type="info" emoji="ℹ️">
Компоненты имеют шаблоны, содержащие HTML и дополнительный синтаксис шаблонов Angular. Они отображают контент. Разработчики размещают компоненты на странице так же, как они размещают собственные элементы HTML и веб-компоненты.

Легче понять, что символ является компонентом, посмотрев HTML-код шаблона.

</Callout>

<Callout
  type="info"
  emoji="ℹ️"
>
  ПОЛЕЗНО: Есть несколько случаев, когда вы присваиваете компоненту атрибут, например, когда вы хотите расширить встроенный элемент. Например, Material Design использует эту технику с `<button mat-button>`. Однако вы не будете использовать этот метод для пользовательского элемента.
</Callout>

{/* prettier-ignore */}
```ts
// ❌ ПЛОХО

@Component({
  standalone: true,
  selector: '[tohHeroButton]',
  templateUrl: './hero-button.component.html',
})
export class HeroButtonComponent {}
```

{/* prettier-ignore */}
```html
<!-- ❌ ПЛОХО -->
<div tohHeroButton></div>
```

{/* prettier-ignore */}
<Tabs items={['hero-button.component.ts', 'hero-button.component.html']}>
  <Tabs.Tab>
    ```ts 
      // ✅ ХОРОШО

      import {Component} from '@angular/core';

      @Component({
        standalone: true,
        selector: 'toh-hero-button',
        templateUrl: './hero-button.component.html',
      })
      export class HeroButtonComponent {}
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```html
      <!-- ✅ ХОРОШО -->

      <toh-hero-button></toh-hero-button>
    ```

  </Tabs.Tab>
</Tabs>

### Извлечение шаблонов и стилей в отдельные файлы.

#### Стиль 05-04

Если в файле больше 3-х строк, извлекайте шаблоны и стили в отдельный файл.

Назовите файл шаблона `[component-name].component.html`, где `[component-name]` — это имя компонента.

Назовите файл стиля `[component-name].component.css`, где `[component-name]` — это имя компонента.

Обязательно указывайте URL-адреса, относящиеся к компонентам, с префиксом `./`.

<Callout type="info" emoji="ℹ️">
Большие встроенные шаблоны и стили скрывают назначение и реализацию компонента, ухудшая читабельность и удобство обслуживания.

В большинстве редакторов подсказки по синтаксису и фрагменты кода недоступны при разработке встроенных шаблонов и стилей. Языковая служба Angular TypeScript (готовится к выпуску) обещает устранить этот недостаток для шаблонов HTML в тех редакторах, которые ее поддерживают; со стилями CSS это не поможет.

Относительный URL-адрес компонента не требует изменений при перемещении файлов компонента, пока файлы остаются вместе.

Префикс `./` является стандартным синтаксисом для относительных URL-адресов; не полагайтесь на текущую способность Angular обходиться без этого префикса.

</Callout>

{/* prettier-ignore */}
```ts filename="heroes.component.ts"
// ❌ ПЛОХО

@Component({
  standalone: true,
  selector: 'toh-heroes',
  template: `
    <div>
      <h2>My Heroes</h2>
      <ul class="heroes">
        @for (hero of heroes | async; track hero) {
        <li (click)="selectedHero = hero">
          <span class="badge">{{ hero.id }}</span> {{ hero.name }}
        </li>
        }
      </ul>
      @if (selectedHero) {
      <div>
        <h2>{{ selectedHero.name | uppercase }} is my hero</h2>
      </div>
      }
    </div>
  `,
  styles: [
    `
      .heroes {
        margin: 0 0 2em 0;
        list-style-type: none;
        padding: 0;
        width: 15em;
      }
      .heroes li {
        cursor: pointer;
        position: relative;
        left: 0;
        background-color: #eee;
        margin: 0.5em;
        padding: 0.3em 0;
        height: 1.6em;
        border-radius: 4px;
      }
      .heroes .badge {
        display: inline-block;
        font-size: small;
        color: white;
        padding: 0.8em 0.7em 0 0.7em;
        background-color: #607d8b;
        line-height: 1em;
        position: relative;
        left: -1px;
        top: -4px;
        height: 1.8em;
        margin-right: 0.8em;
        border-radius: 4px 0 0 4px;
      }
    `,
  ],
  imports: [NgFor, NgIf, AsyncPipe, UpperCasePipe],
})
export class HeroesComponent {
  heroes: Observable<Hero[]>;

  selectedHero!: Hero;

  constructor(private heroService: HeroService) {
    this.heroes = this.heroService.getHeroes();
  }
}
```

{/* prettier-ignore */}
<Tabs items={['heroes.component.ts', 'heroes.component.html', 'heroes.component.css']}>
  <Tabs.Tab>
    ```ts
      // ✅ ХОРОШО

      @Component({
        standalone: true,
        selector: 'toh-heroes',
        templateUrl: './heroes.component.html',
        styleUrls: ['./heroes.component.css'],
        imports: [NgFor, NgIf, AsyncPipe, UpperCasePipe],
      })

      export class HeroesComponent {
        heroes: Observable<Hero[]>;

        selectedHero!: Hero;

        constructor(private heroService: HeroService) {
          this.heroes = this.heroService.getHeroes();
        }
      }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```html
      <!-- ✅ ХОРОШО -->

      <div>
      <h2>My Heroes</h2>
      <ul class="heroes">
        @for (hero of heroes | async; track hero) {
          <li>
            <button type="button" (click)="selectedHero=hero">
              <span class="badge">{{ hero.id }}</span>
              <span class="name">{{ hero.name }}</span>
            </button>
          </li>
        }
      </ul>
      @if (selectedHero) {
        <div>
          <h2>{{ selectedHero.name | uppercase }} is my hero</h2>
        </div>
      }
    </div>
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```css
      .heroes {
        margin: 0 0 2em 0;
        list-style-type: none;
        padding: 0;
        width: 15em;
      }

      .heroes li {
        display: flex;
      }

      .heroes button {
        flex: 1;
        cursor: pointer;
        position: relative;
        left: 0;
        background-color: #EEE;
        margin: .5em;
        padding: 0;
        border-radius: 4px;
        display: flex;
        align-items: stretch;
        height: 1.8em;
      }

      .heroes button:hover {
        color: #2c3a41;
        background-color: #e6e6e6;
        left: .1em;
      }

      .heroes button:active {
        background-color: #525252;
        color: #fafafa;
      }

      .heroes button.selected {
        background-color: black;
        color: white;
      }

      .heroes button.selected:hover {
        background-color: #505050;
        color: white;
      }

      .heroes button.selected:active {
        background-color: black;
        color: white;
      }

      .heroes .badge {
        display: inline-block;
        font-size: small;
        color: white;
        padding: 0.8em 0.7em 0 0.7em;
        background-color: #405061;
        line-height: 1em;
        margin-right: .8em;
        border-radius: 4px 0 0 4px;
      }

      .heroes .name {
        align-self: center;
      }
    ```

  </Tabs.Tab>
</Tabs>

### Декораторы свойств ввода и вывода

#### Стиль 05-12

Используйте декораторы классов `@Input()` и `@Output()` вместо свойств входных и выходных данных метаданных `@Directive` и `@Component`:

Рассмотрите возможность размещения `@Input()` или `@Output()` в той же строке, что и свойство, которое они декорируют.

<Callout type="info" emoji="ℹ️">
Легче и читабельнее определить, какие свойства класса являются входными или выходными.

Если вам когда-нибудь понадобится переименовать свойство или имя события, связанное с @Input() или @Output(), вы можете изменить его в одном месте.

Объявление метаданных, прикрепленное к директиве, короче и, следовательно, более читабельно.

Размещение декоратора в одной строке обычно сокращает код и при этом позволяет легко идентифицировать свойство как входное или выходное. Поместите его в строку выше, если это будет более читабельно.

</Callout>

{/* prettier-ignore */}
```ts filename="hero-button.component.ts"
// ❌ ПЛОХО

@Component({
  standalone: true,
  selector: 'toh-hero-button',
  template: `<button type="button"></button>`,
  inputs: ['label'],
  outputs: ['heroChange'],
})
export class HeroButtonComponent {
  heroChange = new EventEmitter<any>();

  label: string = '';
}
```

{/* prettier-ignore */}
```ts filename="hero-button.component.ts"
  // ✅ ХОРОШО

  @Component({
    standalone: true,
    selector: 'toh-hero-button',
    template: `<button type="button">{{ label }}</button>`,
  })

  export class HeroButtonComponent {
    @Output() heroChange = new EventEmitter<any>();
    @Input() label = '';
  }
```

### Избегайте псевдонимов входов и выходов

#### Стиль 05-13

Избегайте псевдонимов ввода и вывода, за исключением случаев, когда они служат важной цели.

<Callout type="info" emoji="ℹ️">
Два названия одной и той же собственности (частное и общественное) по своей сути сбивают с толку.

Псевдоним следует использовать, если имя директивы также является входным свойством и имя директивы не описывает свойство.

</Callout>

{/* prettier-ignore */}
```ts filename="hero-button.component.ts"
// ❌ ПЛОХО

@Component({
  standalone: true,
  selector: 'toh-hero-button',
  template: `<button type="button">{{ label }}</button>`,
})
export class HeroButtonComponent {
  // Pointless aliases
  @Output('heroChangeEvent') heroChange = new EventEmitter<any>();
  @Input('labelAttribute') label!: string;
}
```

{/* prettier-ignore */}
```html filename="app.component.html"
// ❌ ПЛОХО

<toh-hero-button
  labelAttribute="OK"
  (changeEvent)="doSomething()"
>
</toh-hero-button>
```

{/* prettier-ignore */}
<Tabs items={['hero-button.component.ts', 'hero-highlight.directive.ts', 'app.component.html']}>
  <Tabs.Tab>
    ```ts 
      // ✅ ХОРОШО

      import {Component, EventEmitter, Input, Output} from '@angular/core';

      @Component({
        standalone: true,
        selector: 'toh-hero-button',
        template: `<button type="button" >{{label}}</button>`,
      })

      export class HeroButtonComponent {
        // No aliases
        @Output() heroChange = new EventEmitter<any>();
        @Input() label = '';
      }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```ts
      // ✅ ХОРОШО

      import {Directive, ElementRef, Input, OnChanges} from '@angular/core';

      @Directive({
        standalone: true,
        selector: '[heroHighlight]',
      })

      export class HeroHighlightDirective implements OnChanges {
        // Aliased because `color` is a better property name than `heroHighlight`
        @Input('heroHighlight') color = '';
        constructor(private el: ElementRef) {}
        ngOnChanges() {
          this.el.nativeElement.style.backgroundColor = this.color || 'yellow';
        }
      }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```css
      // ✅ ХОРОШО

      <toh-hero-button label="OK" (change)="doSomething()">
      </toh-hero-button>

      <!-- `heroHighlight` is both the directive name and the data-bound aliased property name -->
      <h3 heroHighlight="skyblue">The Great Bombasto</h3>
    ```

  </Tabs.Tab>
</Tabs>

### Делегируйте сложную логику компонентов сервисам

#### Стиль 05-15

Ограничьте логику в компоненте только тем, что необходимо для представления. Всю остальную логику следует делегировать службам.

Перемещайте повторно используемую логику в сервисы и сохраняйте компоненты простыми и ориентированными на их прямое назначение.

<Callout type="info" emoji="ℹ️">
Логика может повторно использоваться несколькими компонентами, если она помещена в сервис и представлена как функция.

Логику в сервисе легче изолировать с помощью модульного теста, а вызывающую логику в компоненте можно легко имитировать.

Удаляет зависимости и скрывает детали реализации из компонента.

Сохраняет компонент тонким, аккуратным и сфокусированным.

</Callout>

{/* prettier-ignore */}
```ts filename="hero-list.component.ts"
// ❌ ПЛОХО

import { Component, OnInit } from '@angular/core';
import { HttpClient } from '@angular/common/http';

import { Observable } from 'rxjs';
import { catchError, finalize } from 'rxjs/operators';

import { Hero } from '../shared/hero.model';

const heroesUrl = 'http://angular.io';

@Component({
  standalone: true,
  selector: 'toh-hero-list',
  template: `...`,
})
export class HeroListComponent implements OnInit {
  heroes: Hero[];

  constructor(private http: HttpClient) {
    this.heroes = [];
  }

  getHeroes() {
    this.heroes = [];
    this.http
      .get(heroesUrl)
      .pipe(
        catchError(this.catchBadResponse),
        finalize(() => this.hideSpinner()),
      )
      .subscribe((heroes: Hero[]) => (this.heroes = heroes));
  }

  ngOnInit() {
    this.getHeroes();
  }

  private catchBadResponse(err: any, source: Observable<any>) {
    // log and handle the exception
    return new Observable();
  }

  private hideSpinner() {
    // hide the spinner
  }
}
```

{/* prettier-ignore */}
```ts filename="hero-list.component.ts"
// ✅ ХОРОШО

import { Component, OnInit } from '@angular/core';
import { Hero, HeroService } from '../shared';

@Component({
  standalone: true,
  selector: 'toh-hero-list',
  template: `...`,
})
export class HeroListComponent implements OnInit {
  heroes: Hero[] = [];

  constructor(private heroService: HeroService) {}

  getHeroes() {
    this.heroes = [];
    this.heroService.getHeroes().subscribe((heroes) => (this.heroes = heroes));
  }

  ngOnInit() {
    this.getHeroes();
  }
}
```

### Не добавляйте префикс к свойствам вывода

#### Стиль 05-16

Называйте события без префикса.

Назовите методы обработчика событий с префиксом `on`, за которым следует имя события.

<Callout type="info" emoji="ℹ️">
Это согласуется со встроенными событиями, такими как нажатия кнопок.

Angular допускает альтернативный синтаксис `on-`. Если бы само событие имело префикс on, это привело бы к выражению привязки `on-onEvent`.

</Callout>

{/* prettier-ignore */}
```ts filename="hero.component.ts"
// ❌ ПЛОХО

@Component({
  standalone: true,
  selector: 'toh-hero',
  template: `...`,
})
export class HeroComponent {
  @Output() onSavedTheDay = new EventEmitter<boolean>();
}
```

```html filename="app.component.html"
// ❌ ПЛОХО

<toh-hero (onSavedTheDay)="onSavedTheDay($event)"></toh-hero>
```

{/* prettier-ignore */}
<Tabs items={['TS', 'HTML']}>
  <Tabs.Tab>
    ```ts 
      // ✅ ХОРОШО

      export class HeroComponent {
        @Output() savedTheDay = new EventEmitter<boolean>();
      }
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```html
      <!-- ✅ ХОРОШО -->

      <toh-hero (savedTheDay)="onSavedTheDay($event)"></toh-hero>
    ```

  </Tabs.Tab>
</Tabs>

### Поместите логику представления в класс компонента

#### Стиль 05-17

Поместите логику представления в класс компонента, а не в шаблон.

<Callout type="info" emoji="ℹ️">
Логика будет храниться в одном месте (классе компонента), а не разбросана по двум местам.

Сохранение логики представления компонента в классе, а не в шаблоне, улучшает тестируемость, удобство обслуживания и возможность повторного использования.

</Callout>

{/* prettier-ignore */}
```ts filename="hero-list.component.ts"
// ❌ ПЛОХО

@Component({
  standalone: true,
  selector: 'toh-hero-list',
  template: `
    <section>
      Our list of heroes: @for (hero of heroes; track hero) {
      <toh-hero [hero]="hero"></toh-hero>
      } Total powers: {{ totalPowers }}<br />
      Average power: {{ totalPowers / heroes.length }}
    </section>
  `,
  imports: [NgFor, HeroComponent],
})
export class HeroListComponent {
  heroes: Hero[] = [];
  totalPowers: number = 0;
}
```

{/* prettier-ignore */}
```ts filename="hero-list.component.ts"
// ✅ ХОРОШО

@Component({
  standalone: true,
  selector: 'toh-hero-list',
  template: `
    <section>
      Our list of heroes:
      @for (hero of heroes; track hero) {
        <toh-hero [hero]="hero"></toh-hero>
      }
      Total powers: {{totalPowers}}<br>
      Average power: {{avgPower}}
    </section>
  `,
  imports: [NgFor, HeroComponent],
})

export class HeroListComponent {
  heroes: Hero[];
  totalPowers = 0;

...
  get avgPower() {
    return this.totalPowers / this.heroes.length;
  }
}
```

### Инициализировать входы

#### Стиль 05-18

Параметр компилятора TypeScript `--strictPropertyInitialization` гарантирует, что класс инициализирует свои свойства во время создания. Если этот параметр включен, компилятор TypeScript сообщает об ошибке, если класс не устанавливает значение ни для одного свойства, которое явно не помечено как необязательное.

По своей конструкции Angular рассматривает все свойства `@Input` как необязательные. Если это возможно, вы должны удовлетворить `--strictPropertyInitialization`, указав значение по умолчанию.

{/* prettier-ignore */}
```ts filename="hero.component.ts"

@Component({
  standalone: true,
  selector: 'toh-hero',
  template: `...`,
})
export class HeroComponent {
  @Input() id = 'default_id';
}
```

Если для свойства сложно создать значение по умолчанию, используйте `?` чтобы явно пометить свойство как необязательное.

{/* prettier-ignore */}
```ts filename="hero.component.ts"
@Component({
  standalone: true,
  selector: 'toh-hero',
  template: `...`,
})
export class HeroComponent {
  @Input() id?: string;
  process() {
    if (this.id) {
      // ...
    }
  }
}
```

Возможно, вы захотите иметь обязательное поле `@Input`, что означает, что все пользователи вашего компонента должны передать этот атрибут. В таких случаях используйте значение по умолчанию. Просто подавить ошибку TypeScript с помощью `!` недостаточно, и его следует избегать, поскольку это не позволит средству проверки типов обеспечить предоставление входного значения.

{/* prettier-ignore */}
```ts filename="hero.component.ts"
// ❌ ПЛОХО

@Component({
  standalone: true,
  selector: 'toh-hero',
  template: `...`,
})
export class HeroComponent {
  // Восклицательный знак подавляет ошибки о том, что свойство не инициализировано.
  // Игнорирование этого требования может помешать проверке типов от обнаружения потенциальных проблем.
  @Input() id!: string;
}
```

## Директивы

### Используйте директивы для улучшения элемента

#### Стиль 06-01

Используйте директивы атрибутов, если у вас есть логика представления без шаблона.

<Callout type="info" emoji="ℹ️">
Директивы атрибутов не имеют связанного шаблона.

К элементу может быть применено более одной директивы атрибута.

</Callout>

{/* prettier-ignore */}
```ts filename="highlight.component.ts"
@Directive({
  standalone: true,
  selector: '[tohHighlight]',
})
export class HighlightDirective {
  @HostListener('mouseover') onMouseEnter() {
    // do highlight work
  }
}
```

```html filename="app.component.html"
<div tohHighlight>Bombasta</div>
```

### Декораторы `HostListener`/`HostBinding` и метаданные хоста

#### Стиль 06-03

Рассмотрите возможность предпочтения `@HostListener` и `@HostBinding` свойству хоста декораторов `@Directive` и `@Component`.

Будьте последовательны в своем выборе.

<Callout type="info" emoji="ℹ️">
Свойство, связанное с `@HostBinding`, или метод, связанный с `@HostListener`, можно изменить только в одном месте — в классе директивы. Если вы используете свойство метаданных хоста, вы должны изменить как объявление свойства/метода в классе директивы, так и метаданные в декораторе, связанном с директивой.

</Callout>

{/* prettier-ignore */}
```ts
// ✅ ХОРОШО

import { Directive, HostBinding, HostListener } from '@angular/core';
@Directive({
  standalone: true,
  selector: '[tohValidator]',
})
export class ValidatorDirective {
  @HostBinding('attr.role') role = 'button';
  @HostListener('mouseenter') onMouseEnter() {
    // do work
  }
}
```

Сравните с менее предпочтительной альтернативой метаданных хоста.

{/* prettier-ignore */}
```ts
// ❌ ПЛОХО

import { Directive } from '@angular/core';
@Directive({
  standalone: true,
  selector: '[tohValidator2]',
  host: {
    '[attr.role]': 'role',
    '(mouseenter)': 'onMouseEnter()',
  },
})
export class Validator2Directive {
  role = 'button';
  onMouseEnter() {
    // do work
  }
}
```

## Cервисы

### Сервисы являются синглтонами

#### Стиль 07-01

Используйте сервисы как синглтоны в одном инжекторе. Используйте их для обмена данными и функциями.

<Callout type="info" emoji="ℹ️">
Сервисы идеально подходят для обмена методами в рамках функциональной области или приложения.

Сервисы идеально подходят для обмена данными с отслеживанием состояния в памяти.

</Callout>

{/* prettier-ignore */}
```ts
export class HeroService {
  constructor(private http: HttpClient) {}
  getHeroes() {
    return this.http.get<Hero[]>('api/heroes');
  }
}
```

### Предоставление услуги

#### Стиль 07-03

Предоставляйте сервис с корневым инжектором приложения в декораторе `@Injectable` сервиса.

<Callout type="info" emoji="ℹ️">
Angular инжектор имеет иерархическую структуру.

Когда вы предоставляете службу корневому инжектору, этот экземпляр службы является общим и доступен в каждом классе, которому нужна эта служба. Это идеально, когда служба совместно использует методы или состояние.

Когда вы регистрируете службу в декораторе `@Injectable` службы, инструменты оптимизации, такие как те, которые используются в рабочих сборках Angular CLI, могут выполнять встряхивание дерева и удалять службы, которые не используются вашим приложением.

Это не идеальный вариант, когда двум разным компонентам требуются разные экземпляры службы. В этом сценарии было бы лучше предоставить услугу на уровне компонента, которому нужен новый отдельный экземпляр.

</Callout>

{/* prettier-ignore */}
```ts
import { Injectable } from '@angular/core';
@Injectable({
  providedIn: 'root',
})
export class Service {}
```

### Используйте декоратор класса `@Injectable()`

#### Стиль 07-04

Используйте декоратор класса `@Injectable()` вместо декоратора параметров `@Inject` при использовании типов в качестве токенов для зависимостей службы.

<Callout type="info" emoji="ℹ️">
Механизм Angular Dependency Injection (DI) разрешает собственные зависимости службы на основе объявленных типов параметров конструктора этой службы.

Когда служба принимает только зависимости, связанные с токенами типа, синтаксис `@Injectable()` гораздо менее подробный по сравнению с использованием `@Inject()` для каждого отдельного параметра конструктора.

</Callout>

{/* prettier-ignore */}
```ts
// ❌ ПЛОХО

export class HeroArena {
  constructor(
    @Inject(HeroService) private heroService: HeroService,
    @Inject(HttpClient) private http: HttpClient,
  ) {}
}
```

{/* prettier-ignore */}
```ts
// ✅ ХОРОШО

@Injectable()
export class HeroArena {
  constructor(
    private heroService: HeroService,
    private http: HttpClient,
  ) {}
...
}
```

## Службы передачи данных

### Сообщение с сервером через сервис

#### Стиль 08-01

Выполните рефакторинг логики для выполнения операций с данными и взаимодействия с данными в сервисе.

Сделайте службы данных ответственными за вызовы XHR, локальное хранилище, хранение в памяти или любые другие операции с данными.

<Callout type="info" emoji="ℹ️">
Ответственность компонента заключается в представлении и сборе информации для представления. Его не должно волновать, как он получает данные, главное, чтобы он знал, у кого их запросить. Разделение служб данных перемещает логику того, как передать их в службу данных, и позволяет компоненту быть проще и более ориентированным на представление.

Это упрощает тестирование (ложное или реальное) вызовов данных при тестировании компонента, использующего службу данных.

Детали управления данными, такие как заголовки, методы HTTP, кэширование, обработка ошибок и логика повторов, не имеют значения для компонентов и других потребителей данных.

</Callout>

Служба данных инкапсулирует эти детали. Эти детали легче развивать внутри службы, не затрагивая ее потребителей. И проще тестировать потребителей с помощью макетных реализаций сервисов.

## Перехватчики жизненного цикла

Используйте перехватчики жизненного цикла, чтобы отслеживать важные события, предоставляемые Angular.

### Реализация интерфейсов перехватчиков жизненного цикла

#### Стиль 09-01

Обязательно реализуйте интерфейсы перехватчиков жизненного цикла.

<Callout type="info" emoji="ℹ️">
Интерфейсы жизненного цикла предписывают типизированные сигнатуры методов. Используйте эти подписи, чтобы отмечать орфографические и синтаксические ошибки.

</Callout>

{/* prettier-ignore */}
```ts
// ❌ ПЛОХО

@Component({
  standalone: true,
  selector: 'toh-hero-button',
  template: `<button type="button">OK</button>`,
})
export class HeroButtonComponent {
  onInit() {
    // misspelled
    console.log('The component is initialized');
  }
}
```

{/* prettier-ignore */}
```ts
// ✅ ХОРОШО

@Component({
  standalone: true,
  selector: 'toh-hero-button',
  template: `<button type="button">OK</button>`,
})
export class HeroButtonComponent implements OnInit {
  ngOnInit() {
    console.log('The component is initialized');
  }
}
```

## Приложение

Полезные инструменты и советы по Angular.

### Шаблоны файлов и фрагменты

#### Стиль А-02

Используйте шаблоны файлов или фрагменты, чтобы следовать единообразным стилям и шаблонам. Вот шаблоны и/или фрагменты для некоторых редакторов и IDE для веб-разработки.

Рассмотрите возможность использования [сниппетов](https://marketplace.visualstudio.com/items?itemName=johnpapa.Angular2) кода [Visual Studio](https://code.visualstudio.com/), соответствующих этим стилям и рекомендациям.

Рассмотрите возможность использования [сниппетов](https://github.com/orizens/sublime-angular2-snippets) для [Sublime Text](https://www.sublimetext.com/), соответствующих этим стилям и рекомендациям.

Рассмотрите возможность использования [сниппетов](https://marketplace.visualstudio.com/items?itemName=johnpapa.Angular2) кода для Vim, соответствующих этим стилям и рекомендациям.
